# Rust API Guidelines - Полное руководство

> Это набор рекомендаций по проектированию и представлению API для языка программирования Rust. Составлены командой Rust library team на основе опыта создания стандартной библиотеки Rust и других крейтов в экосистеме Rust.

## Оглавление

- [О руководстве](#о-руководстве)
- [Naming - Именование](#naming---именование)
- [Interoperability - Взаимодействие](#interoperability---взаимодействие)
- [Macros - Макросы](#macros---макросы)
- [Documentation - Документация](#documentation---документация)
- [Predictability - Предсказуемость](#predictability---предсказуемость)
- [Flexibility - Гибкость](#flexibility---гибкость)
- [Type Safety - Типобезопасность](#type-safety---типобезопасность)
- [Dependability - Надежность](#dependability---надежность)
- [Debuggability - Отлаживаемость](#debuggability---отлаживаемость)
- [Future Proofing - Защита от будущих изменений](#future-proofing---защита-от-будущих-изменений)
- [Necessities - Необходимости](#necessities---необходимости)

---

## О руководстве

Это набор рекомендаций, некоторые более строгие, чем другие. В некоторых случаях они расплывчаты и все еще находятся в разработке. Авторы крейтов Rust должны рассматривать их как набор важных соображений при разработке идиоматичных и совместимых библиотек Rust.

Эти руководства **не являются обязательными**, но крейты, которые хорошо соответствуют этим рекомендациям, лучше интегрируются с существующей экосистемой крейтов.

---

## Naming - Именование

### C-CASE: Соответствие RFC 430

Базовые конвенции именования Rust описаны в RFC 430. В общем, Rust использует:
- **UpperCamelCase** для конструкций "типового уровня" (типы и трейты)
- **snake_case** для конструкций "значимого уровня"

**Детали:**

| Элемент | Конвенция |
|---------|-----------|
| Crates | `snake_case` (предпочтительно одно слово) |
| Modules | `snake_case` |
| Types | `UpperCamelCase` |
| Traits | `UpperCamelCase` |
| Enum variants | `UpperCamelCase` |
| Functions | `snake_case` |
| Methods | `snake_case` |
| General constructors | `new` или `with_...` |
| Conversion constructors | `from_...` |
| Local variables | `snake_case` |
| Static variables | `SCREAMING_SNAKE_CASE` |
| Constant variables | `SCREAMING_SNAKE_CASE` |
| Type parameters | краткий `UpperCamelCase`, обычно одна буква: `T` |
| Lifetimes | короткий `lowercase`, обычно одна буква: `'a` |

**Правила для акронимов:**
- В `UpperCamelCase` акронимы считаются одним словом: используйте `Uuid`, а не `UUID`
- В `snake_case` акронимы в нижнем регистре: `is_xid_start`
- В `snake_case` или `SCREAMING_SNAKE_CASE` "слово" никогда не должно состоять из одной буквы, кроме как в последнем слове: `btree_map`, а не `b_tree_map`, но `PI_2`, а не `PI2`

**Имена крейтов:**
- НЕ используйте `-rs` или `-rust` как суффикс или префикс
- Каждый крейт - это Rust! Не нужно постоянно напоминать пользователям об этом

### C-CONV: Ad-hoc конверсии следуют конвенциям as_, to_, into_

Преобразования должны предоставляться как методы с именами, имеющими следующие префиксы:

| Префикс | Стоимость | Владение |
|---------|----------|----------|
| `as_` | Бесплатно | borrowed -> borrowed |
| `to_` | Дорого | borrowed -> borrowed<br>borrowed -> owned (не Copy)<br>owned -> owned (Copy) |
| `into_` | Переменная | owned -> owned (не Copy) |

**Примеры:**

```rust
// str::as_bytes() - бесплатное представление str как срез UTF-8 байтов
// Вход: borrowed &str, Выход: borrowed &[u8]
str::as_bytes()

// Path::to_str - дорогая проверка UTF-8 байтов пути ОС
// Вход и выход: оба borrowed
Path::to_str()

// str::to_lowercase() - производит корректный Unicode нижний регистр
// требует итерации по символам и может требовать выделения памяти
// Вход: borrowed &str, Выход: owned String
str::to_lowercase()

// String::into_bytes() - берет владение String и возвращает Vec<u8>
String::into_bytes()
```

**Если `mut` является частью типа возвращаемого значения:**
```rust
// Возвращаемый тип - mut slice
fn as_mut_slice(&mut self) -> &mut [T];
// Предпочтительнее, чем as_slice_mut
```

### C-GETTER: Геттеры следуют конвенции Rust

За несколькими исключениями, префикс `get_` **не используется** для геттеров в коде Rust.

```rust
pub struct S {
    first: First,
    second: Second,
}

impl S {
    // Не get_first
    pub fn first(&self) -> &First {
        &self.first
    }

    // Не get_first_mut, get_mut_first, или mut_first
    pub fn first_mut(&mut self) -> &mut First {
        &mut self.first
    }
}
```

**Именование `get` используется только**, когда есть одна очевидная вещь, которую можно получить. Например, `Cell::get` получает доступ к содержимому `Cell`.

Для геттеров, которые выполняют проверку во время выполнения (например, проверку границ), рассмотрите добавление unsafe вариантов `_unchecked`.

### C-ITER: Методы коллекций для создания итераторов

Для контейнера с элементами типа `U`, методы итератора должны называться:

```rust
fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>
fn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>
fn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>
```

**Это руководство применяется к:**
- Структурам данных, которые концептуально являются однородными коллекциями
- **Только методам, не функциям**

**Контрпример:** Тип `str` - это срез байтов, гарантированно являющихся валидным UTF-8. Это концептуально более нюансировано, чем однородная коллекция, поэтому вместо `iter/iter_mut/into_iter` он предоставляет:
- `str::bytes` - для итерации как байты
- `str::chars` - для итерации как символы

### C-ITER-TY: Имена типов итераторов соответствуют методам, которые их создают

```rust
// Функция percent_encode из крейта url возвращает тип итератора PercentEncode
percent_encode() -> PercentEncode

// Эти имена типов наиболее осмысленны с префиксом модуля
vec::IntoIter
```

### C-FEATURE: Имена фич свободны от слов-заполнителей

**Не включайте** слова в имя Cargo feature, которые не передают смысла, например `use-abc` или `with-abc`. Называйте feature просто `abc`.

**Особенно для опциональной зависимости от стандартной библиотеки:**

```toml
# В Cargo.toml
[features]
default = ["std"]
std = []
```

```rust
// В lib.rs
#![no_std]

#[cfg(feature = "std")]
extern crate std;
```

**НЕ** называйте feature `use-std` или `with-std` или любым креативным именем, не являющимся `std`.

Эта конвенция именования согласуется с именованием неявных фич, выводимых Cargo для опциональных зависимостей.

### C-WORD-ORDER: Имена используют последовательный порядок слов

Если API определяет множество имен с общими словами, используйте последовательный порядок слов.

**Плохо:**
```rust
struct ParseError;          // verb-object-error
struct AddrParseError;      // object-verb-error (несогласованно!)
```

**Хорошо:**
```rust
struct ParseError;          // verb-object-error
struct ParseAddrError;      // verb-object-error (согласованно!)
```

**Порядок слов - глагол-объект-ошибка** должен быть последовательным во всем API.

---

## Interoperability - Взаимодействие

### C-COMMON-TRAITS: Типы активно реализуют общие трейты

Система трейтов Rust не разрешает "сирот": каждая impl должна находиться либо в крейте, определяющем трейт, либо в крейте, определяющем реализующий тип. Следовательно, крейты, определяющие новые типы, должны активно реализовывать все применимые общие трейты.

**Наиболее важные общие трейты из std:**

**Для данных:**
- `Copy` - для простых типов, которые можно копировать битовым копированием
- `Clone` - для типов с более сложной семантикой копирования
- `Eq`, `PartialEq` - для типов, которые можно сравнивать на равенство
- `Ord`, `PartialOrd` - для типов, которые можно упорядочивать
- `Hash` - для типов, которые можно хэшировать
- `Debug` - для типов, которые можно форматировать для отладки
- `Display` - для типов с "user-facing" представлением
- `Default` - для типов с разумным значением по умолчанию

**Примечание:** Обычно и ожидается, что типы реализуют и `Default`, и пустой конструктор `new()`. `new` - это конструкторская конвенция в Rust, и пользователи ожидают его существования.

### C-CONV-TRAITS: Преобразования используют стандартные трейты

Трейты преобразования из стандартной библиотеки:
- `From` - для безошибочных преобразований
- `TryFrom` - для преобразований, которые могут завершиться ошибкой
- `AsRef` - для легких ссылочных преобразований
- `AsMut` - для легких изменяемых ссылочных преобразований

```rust
// Автоматический бланкет impl для Into из From
impl<T, U> Into<U> for T where U: From<T>

// То же для TryInto из TryFrom
impl<T, U> TryInto<U> for T where U: TryFrom<T>
```

**Никогда не реализуйте `Into` или `TryInto` вручную.** Реализуйте `From` и `TryFrom` вместо этого.

### C-COLLECT: Коллекции реализуют FromIterator и Extend

```rust
trait FromIterator<A> {
    fn from_iter<T>(iter: T) -> Self where T: IntoIterator<Item = A>;
}

trait Extend<A> {
    fn extend<T>(&mut self, iter: T) where T: IntoIterator<Item = A>;
}
```

Эти трейты позволяют:
- Создавать коллекции из итераторов
- Расширять существующие коллекции

### C-SERDE: Структуры данных реализуют Serialize и Deserialize от Serde

**Continuum типов:**
- **Явно структуры данных:** `LinkedHashMap`, `IpAddr` - разумно читать из JSON или отправлять через IPC
- **Явно НЕ структуры данных:** `LittleEndian` из byteorder - маркер времени компиляции, никогда не существует во время выполнения

Если крейт еще не зависит от Serde, можно поместить Serde impls за Cargo cfg:

```toml
[features]
serde = ["serde/std"]

[dependencies]
serde = { version = "1.0", optional = true }
```

```rust
pub struct T { /* ... */ }

#[cfg(feature = "serde")]
impl Serialize for T { /* ... */ }

#[cfg(feature = "serde")]
impl<'de> Deserialize<'de> for T { /* ... */ }
```

**Для консистентности** имя Cargo cfg должно быть просто `"serde"`, не `"serde_impls"` или `"serde_serialization"`.

### C-SEND-SYNC: Типы являются Send и Sync где возможно

`Send` и `Sync` автоматически реализуются, когда компилятор определяет, что это уместно.

**Особенно для типов ошибок:**
- Ошибка, которая не `Send`, не может быть возвращена потоком, запущенным с `thread::spawn`
- Ошибка, которая не `Sync`, не может быть передана между потоками через `Arc`
- Это общие требования для базовой обработки ошибок в многопоточных приложениях

`Send` и `Sync` также важны для упаковки пользовательской ошибки в IO ошибку используя `std::io::Error::new`, которая требует trait bound `Error + Send + Sync`.

### C-GOOD-ERR: Типы ошибок осмысленны и хорошо себя ведут

**Никогда не используйте `()` как тип ошибки,** даже когда нет полезной дополнительной информации. `()` не реализует `std::error::Error`, что вызывает проблемы для вызывающих, которые ожидают возможности преобразовать ошибки в `Error`.

**Вместо этого определите осмысленный тип ошибки:**

```rust
use std::error::Error;
use std::fmt::{Display, Formatter, Result};

#[derive(Debug)]
pub struct ParseBoolError {
    _priv: (),
}

impl Display for ParseBoolError {
    fn fmt(&self, f: &mut Formatter) -> Result {
        "provided string was not `true` or `false`".fmt(f)
    }
}

impl Error for ParseBoolError {}
```

**Дополнительно, типы ошибок должны реализовывать Send и Sync трейты** (см. C-SEND-SYNC).

### C-NUM-FMT: Двоичные числовые типы предоставляют Hex, Octal, Binary форматирование

```rust
use std::fmt::{Binary, Octal, LowerHex, UpperHex};

impl Binary for MyNumber { /* ... */ }
impl Octal for MyNumber { /* ... */ }
impl LowerHex for MyNumber { /* ... */ }
impl UpperHex for MyNumber { /* ... */ }
```

Реализуйте эти трейты для любого числового типа, на котором вы бы рассматривали битовые манипуляции, такие как `|` или `&`. Особенно подходит для типов bitflag.

Числовые типы количества, такие как `struct Nanoseconds(u64)`, вероятно, не нуждаются в них.

### C-RW-VALUE: Функции generic reader/writer принимают R: Read и W: Write по значению

```rust
impl<'a, R: Read + ?Sized> Read for &'a mut R { /* ... */ }
impl<'a, W: Write + ?Sized> Write for &'a mut W { /* ... */ }
```

Это означает, что любая функция, принимающая generic параметры `R: Read` или `W: Write` по значению, может быть вызвана с `mut` ссылкой при необходимости.

**В документации таких функций** кратко напомните пользователям, что может быть передана `mut` ссылка. Новые пользователи Rust часто сталкиваются с этим.

---

## Macros - Макросы

### C-EVOCATIVE: Входной синтаксис вызывает ассоциации с выходом

Макросы Rust позволяют создавать практически любой входной синтаксис. Стремитесь сохранить синтаксис знакомым и когерентным с остальным кодом пользователей, отражая существующий синтаксис Rust, где возможно.

**Обратите внимание на выбор и размещение ключевых слов и пунктуации.**

```rust
// Предпочтительно...
bitflags! {
    struct S: u32 { /* ... */ }
}

// ...а не без ключевого слова...
bitflags! {
    S: u32 { /* ... */ }
}

// ...или какого-то ad-hoc слова
bitflags! {
    flags S: u32 { /* ... */ }
}
```

**Пример с точкой с запятой vs запятой:**

Константы в Rust следуют за точкой с запятой, поэтому если ваш макрос объявляет цепочку констант, они должны, вероятно, следовать за точкой с запятой:

```rust
// Обычные константы используют точки с запятой
const A: u32 = 0b000001;
const B: u32 = 0b000010;

// Предпочтительно...
bitflags! {
    struct S: u32 {
        const C = 0b000100;
        const D = 0b001000;
    }
}

// ...а не это
bitflags! {
    struct S: u32 {
        const E = 0b010000,
        const F = 0b100000,
    }
}
```

### C-MACRO-ATTR: Макросы хорошо компонуются с атрибутами

Макросы, которые производят более одного выходного элемента, должны поддерживать добавление атрибутов к любому из этих элементов.

```rust
bitflags! {
    struct Flags: u8 {
        #[cfg(windows)]
        const ControlCenter = 0b001;
        
        #[cfg(unix)]
        const Terminal = 0b010;
    }
}
```

**Один распространенный случай использования** - поместить отдельные элементы за `cfg`.

### C-ANYWHERE: Item макросы работают везде, где разрешены элементы

```rust
#[cfg(test)]
mod tests {
    bitflags! {
        struct SomeFlags: u32 {
            const FLAG_A = 0b00000001;
        }
    }
}

fn main() {
    bitflags! {
        struct MoreFlags: u8 {
            const FLAG_B = 0b00000001;
        }
    }
}
```

Пользователи должны иметь возможность вызывать item макрос в любом месте программы, где им может потребоваться соответствующий элемент.

### C-MACRO-VIS: Item макросы поддерживают спецификаторы видимости

Следуйте синтаксису Rust для видимости элементов, производимых макросом. Приватный по умолчанию, публичный, если указано `pub`.

```rust
bitflags! {
    struct PrivateFlags: u8 {
        const A = 0b0001;
        const B = 0b0010;
    }
}

bitflags! {
    pub struct PublicFlags: u8 {
        const C = 0b0100;
        const D = 0b1000;
    }
}
```

### C-MACRO-TY: Фрагменты типов гибкие

Если ваш макрос принимает фрагмент типа, такой как `$t:ty` во входе, он должен быть пригоден для использования со всеми следующими:

- Примитивные типы: `u8`, `&str`
- Относительные пути: `m::Data`
- Абсолютные пути: `::base::Data`
- Восходящие пути: `super::Data`
- Обобщенные типы: `Vec<String>`

**Простой пример, как все может пойти не так:**

```rust
macro_rules! bad_macro {
    ($t:ty) => {
        fn f(arg: $t) { /* ... */ }
    }
}

// Работает для примитивов и абсолютных путей
bad_macro!(u8);
bad_macro!(::std::string::String);

// Не работает для относительных путей
// bad_macro!(String); // ОШИБКА
```

---

## Documentation - Документация

### C-CRATE-DOC: Документация уровня крейта тщательна и включает примеры

**Библиотека должна иметь документацию уровня крейта** (`//!` комментарии в lib.rs), содержащую:

- Описание функциональности крейта
- Примеры основных случаев использования
- Ссылки на наиболее важные типы и функции

**Примеры** должны демонстрировать типичное использование, а не просто механически показывать, как вызывать функции.

### C-EXAMPLE: Все элементы имеют rustdoc пример

**Каждый публичный модуль, трейт, структура, enum, функция, метод, макрос и определение типа должны иметь пример**, который демонстрирует функциональность.

**Примечание:**
- Применяйте это руководство в разумных пределах
- Ссылка на применимый пример на другом элементе может быть достаточной
- Цель примера часто не в том, чтобы показать **как** использовать элемент, а **почему** кто-то захотел бы его использовать

**Плохой пример:**

```rust
// Механически показывает, КАК вызывать clone(), но ничего не показывает
// о том, ПОЧЕМУ кто-то захотел бы это
fn main() {
    let hello = "hello";
    hello.clone();
}
```

### C-QUESTION-MARK: Примеры используют ?, а не try!, не unwrap

**Нравится это или нет, код примеров часто копируется дословно пользователями.**

Unwrapping ошибки должно быть осознанным решением, которое пользователь должен принять.

```rust
/// ```rust
/// # use std::error::Error;
/// #
/// # fn main() -> Result<(), Box<dyn Error>> {
/// your;
/// example?;
/// code;
/// #
/// #     Ok(())
/// # }
/// ```
```

**Используйте оператор `?`** для обработки ошибок в примерах, а не `try!` или `unwrap`.

### C-FAILURE: Документация функций включает рассмотрения ошибок, паник и безопасности

**Ошибки:**

Условия ошибок должны быть документированы в разделе "# Errors".

```rust
/// # Errors
///
/// Если эта функция встречает какую-либо форму I/O или другой ошибки,
/// возвращается вариант ошибки. Если возвращается ошибка, гарантируется,
/// что байты не были прочитаны.
fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>
```

**Паники:**

Условия паники должны быть документированы в разделе "# Panics".

```rust
/// # Panics
///
/// Паникует, если индекс выходит за границы среза.
fn get(&self, index: usize) -> &T
```

**Безопасность:**

Unsafe функции должны документировать их инварианты безопасности в разделе "# Safety".

```rust
/// # Safety
///
/// Вызывающий должен гарантировать, что указатель валиден и правильно выровнен.
unsafe fn read_unaligned<T>(ptr: *const T) -> T
```

### C-LINK: Проза содержит гиперссылки на соответствующие вещи

**Это руководство официально рекомендовано RFC 1574** под заголовком "Link all the things".

```rust
/// Связывайте на другие типы используя [`text`]
///
/// [`text`]: crate::module::Type
```

**Обычные ссылки** могут быть добавлены inline с обычным markdown синтаксисом `[text](url)`.

### C-METADATA: Cargo.toml включает все общие метаданные

```toml
[package]
name = "..."
version = "..."
authors = ["..."]
license = "MIT OR Apache-2.0"
homepage = "..."
documentation = "..."
repository = "..."
keywords = ["..."]
categories = ["..."]
description = "..."
```

**Примечания:**
- `documentation` нужно устанавливать только если документация размещена не на docs.rs
- `homepage` должна быть установлена только если есть уникальный веб-сайт для крейта

### C-RELNOTES: Release notes документируют все значительные изменения

Пользователи крейта могут читать release notes, чтобы найти резюме того, что изменилось в каждом опубликованном релизе крейта.

**Для проектов на Git:**

```bash
# Тегируйте текущий коммит
GIT_COMMITTER_DATE=$(git log -n1 --pretty=%cI) \
  git tag -a -m "Release 0.3.0" 0.3.0
git push --tags
```

Каждый релиз, опубликованный на crates.io, должен иметь соответствующий тег, идентифицирующий коммит, который был опубликован.

### C-HIDDEN: Rustdoc не показывает бесполезные детали реализации

Rustdoc должен включать все, что нужно пользователям для использования крейта полностью, **и ничего более**.

**Особенно будьте избирательны** в отношении того, какие impls видимы в rustdoc - все те, которые пользователям понадобятся для использования крейта полностью, но никакие другие.

```rust
// Этот тип ошибки возвращается пользователям
pub struct PublicError { /* ... */ }

// Этот тип ошибки возвращается некоторыми приватными вспомогательными функциями
struct PrivateError { /* ... */ }

// Включить использование оператора `?`
#[doc(hidden)]
impl From<PrivateError> for PublicError {
    fn from(err: PrivateError) -> PublicError {
        /* ... */
    }
}
```

`pub(crate)` - еще один отличный инструмент для удаления деталей реализации из публичного API.

---

## Predictability - Предсказуемость

### C-SMART-PTR: Умные указатели не добавляют наследуемые методы

Умные указатели (`Box`, `Rc`, `Arc`, etc.) **не должны добавлять наследуемые методы** за пределами тех, которые есть в указываемом типе.

Причина: Умные указатели реализуют `Deref`, поэтому методы на указываемом типе напрямую доступны на умном указателе.

### C-CONV-SPECIFIC: Преобразования живут на наиболее конкретном вовлеченном типе

**Три различия** между конструктором преобразования с префиксом `from_` и impl `From<T>`:

1. **`From<T>` impl применяется только**, когда исходный тип данных достаточен для определения кодирования выходного типа данных
2. **`From<T>` impl могут быть только один** для данной комбинации типов
3. **Конструктор с префиксом `from_`** может принимать дополнительные параметры, чтобы уточнить кодирование

```rust
// From impl подходит
impl From<i32> for BigInt

// Конструктор from_ лучше, когда исходные данные - просто "мешок битов"
u64::from_be()
String::from_utf8()
```

### C-METHOD: Функции с четким получателем являются методами

```rust
// Хорошо
impl Foo {
    pub fn frob(&self, w: widget) { /* ... */ }
}

// Плохо
pub fn frob(foo: &Foo, w: widget) { /* ... */ }
```

**Преимущества методов:**
- Не нужно импортировать или квалифицировать для использования
- Выполняют автозаимствование (включая изменяемые заимствования)
- Упрощают ответ на вопрос "что я могу сделать со значением типа T"
- Предоставляют self нотацию, которая более лаконична
- Четко передают различия владения

### C-NO-OUT: Функции не принимают out-параметры

**Предпочитайте возвращать значения напрямую,** даже если это означает возврат составного типа, такого как кортеж или struct.

```rust
// Хорошо
fn pop(&mut self) -> Option<T>

// Плохо
fn pop(&mut self, out: &mut T) -> bool
```

**Исключение:** Иногда функция предназначена для модификации данных, которыми владеет вызывающий, например, для повторного использования буфера:

```rust
fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>
```

### C-OVERLOAD: Перегрузки операторов неудивительны

Операторы с встроенным синтаксисом (`*`, `|` и т.д.) могут быть предоставлены для типа путем реализации трейтов в `std::ops`.

**Эти трейты должны реализовываться только для семантики операторов, не удивляющей пользователей.**

### C-DEREF: Только умные указатели реализуют Deref и DerefMut

`Deref` и `DerefMut` трейты используются **неявно компилятором** во многих обстоятельствах. Публичные API, которые могут неявно вызывать код в пользовательских типах, должны использоваться с осторожностью и только для умных указателей.

**Не злоупотребляйте** Deref для эмуляции наследования между структурами.

### C-CTOR: Конструкторы являются статическими, наследуемыми методами

В Rust "конструкторы" - просто конвенция. Существует разнообразие конвенций вокруг именования конструкторов.

**Базовый конструктор:**

```rust
impl<T> Example<T> {
    pub fn new() -> Example<T> {
        /* ... */
    }
}
```

**Использование:**

```rust
use example::Example;

// Создать новый Example
let ex = Example::new();
```

**Имя `new` должно обычно использоваться** для первичного метода создания экземпляра типа.

**Другие конструкторы:**

```rust
// Конструкторы I/O ресурсов используют специфичные имена для домена
File::open()
Mmap::open()
TcpStream::connect()
UdpSocket::bind()

// Вторичные конструкторы часто имеют суффикс _with_foo
Mmap::open_with_offset()

// Конструкторы преобразования
std::io::Error::from_raw_os_error()

// С множеством опций конструирования
std::process::Command - использует builder pattern
```

**Некоторые конструкторы - "конструкторы преобразования"**, методы, создающие новый тип из существующего значения другого типа:
- Часто имеют имена, начинающиеся с `from_`
- Обратите внимание на трейт `From` (C-CONV-TRAITS)

**Три различия между конструктором `from_-prefixed` и impl `From<T>`:**

1. impl `From` применяется только когда исходный тип данных достаточен для определения кодирования выходного типа
2. impl `From` может быть только один для данной комбинации типов
3. Конструктор `from_` может принимать дополнительные параметры

**Примеры:**
- `std::io::Error::new` - часто используемый конструктор для IO ошибки
- `std::io::Error::from_raw_os_error` - конструктор преобразования на основе кода ошибки от ОС
- `Box::new` - создает новый контейнерный тип, принимая один аргумент
- `File::open` - открывает файловый ресурс

---

## Flexibility - Гибкость

### C-INTERMEDIATE: Функции предоставляют промежуточные результаты

**Если выполнение операции требует некоторой дорогостоящей настройки**, рассмотрите возможность предоставления функций, которые возвращают промежуточные результаты для избежания дублирующей работы.

**Пример:**

```rust
// Вместо
fn parse_and_validate(input: &str) -> Result<Data, Error>

// Предоставьте
fn parse(input: &str) -> Result<ParsedData, ParseError>
fn validate(data: ParsedData) -> Result<Data, ValidationError>
```

### C-CALLER-CONTROL: Вызывающий решает, где копировать и размещать данные

**Предпочитайте**:
- Возвращать owned данные (`String`, `Vec<T>`, `HashMap<K,V>`)
- Принимать borrowed данные (`&str`, `&[T]`)

```rust
// Хорошо - вызывающий контролирует
pub fn parse(input: &str) -> Result<Data, Error>
pub fn serialize(data: &Data) -> String

// Плохо - функция заставляет выделение
pub fn parse(input: String) -> Result<Data, Error>
```

**Причина:** Вызывающий может иметь данные уже в правильной форме и не хочет выделять дополнительно.

### C-GENERIC: Функции минимизируют предположения о параметрах используя generics

**Используйте generics** для принятия широкого диапазона типов, где возможно:

```rust
// Хорошо - принимает любой AsRef<Path>
pub fn open<P: AsRef<Path>>(path: P) -> Result<File>

// Пример использования
File::open("f.txt")           // &str
File::open(Path::new("f.txt")) // Path
File::open(PathBuf::from("f.txt")) // PathBuf
```

**Преимущества generics:**

1. **Повторное использование** - могут применяться к открытой коллекции типов
2. **Статический диспетчинг и оптимизация** - каждое использование специализировано ("мономорфизовано")
3. **Inline компоновка** - значения типа `T` размещаются inline в struct/enum
4. **Вывод типов** - параметры типа обычно могут быть выведены
5. **Точные типы** - можете быть точными о местах, где требуется/производится точный тип

**Компромиссы:**

1. **Размер кода** - специализация дублирует тело функции
2. **Гомогенные типы** - `Vec<T>` содержит элементы одного конкретного типа

### C-OBJECT: Трейты являются object-safe если они могут быть полезны как trait object

**Trait objects имеют значительные ограничения:**
- Методы не могут использовать generics
- Не могут использовать `Self` кроме как в позиции получателя

**При проектировании трейта решите рано**, будет ли трейт использоваться как объект или как bound на generics.

**Если трейт предназначен для использования как объект**, его методы должны принимать и возвращать trait objects, а не использовать generics.

```rust
// Не object-safe из-за generic метода
trait MyTrait {
    fn object_safe(&self, i: i32);
    fn not_object_safe<T>(&self, t: T);
}

// Добавление Self: Sized исключает метод из trait object
trait MyTrait {
    fn object_safe(&self, i: i32);
    
    // Этот метод не может быть вызван на trait object
    fn not_object_safe<T>(&self, t: T) where Self: Sized;
}
```

**Примеры trait objects:** `io::Read` и `io::Write` часто используются как объекты.

---

## Type Safety - Типобезопасность

### C-NEWTYPE: Newtypes обеспечивают статические различия

**Newtype pattern** - обертка вокруг существующего типа, которая позволяет определить отличительные семантики.

```rust
pub struct Ascii(u8);
```

**Преимущества:**
- Поддерживает "typesafe" API: принимая `Color`, а не целое число, функция гарантированно получает хорошо сформированные входные данные
- Компилятор обеспечивает, что обернутое значение используется правильно

**Пример:**

```rust
pub struct Hostname(String);
pub struct Port(u16);

// Невозможно случайно перепутать
pub fn connect(host: Hostname, port: Port) -> Result<Connection>
```

### C-CUSTOM-TYPE: Аргументы передают смысл через типы, а не bool или Option

**Вместо:**

```rust
// Что означает true?
pub fn new(admin: bool) -> User

// Что означает None?
pub fn render(border: Option<Color>) -> Image
```

**Используйте:**

```rust
pub enum Role {
    Admin,
    Regular,
}

pub fn new(role: Role) -> User

pub enum Border {
    None,
    Solid(Color),
    Dashed(Color),
}

pub fn render(border: Border) -> Image
```

**Custom типы делают код:**
- Более самодокументируемым
- Защищенным от ошибок
- Легким для расширения в будущем

### C-BITFLAG: Типы для набора флагов - это bitflags, а не enums

**Enum позволяет API запросить ровно один выбор** среди многих.

**Иногда вход API - это присутствие или отсутствие набора флагов.** Крейт `bitflags` Rust предоставляет typesafe представление этого паттерна:

```rust
use bitflags::bitflags;

bitflags! {
    pub struct Flags: u32 {
        const FLAG_A = 0b00000001;
        const FLAG_B = 0b00000010;
        const FLAG_C = 0b00000100;
    }
}

// Использование
fn process(flags: Flags) {
    if flags.contains(Flags::FLAG_A) {
        // ...
    }
}

process(Flags::FLAG_A | Flags::FLAG_B);
```

### C-BUILDER: Билдеры обеспечивают конструирование сложных значений

**Builder pattern особенно подходит когда:**
- Конструирование `T` включает побочные эффекты (создание задачи, запуск процесса)
- Есть множество способов конфигурировать конструирование

**Два варианта builder pattern:**

#### 1. Non-consuming builders

```rust
pub struct Command {
    program: String,
    args: Vec<String>,
    cwd: Option<String>,
}

impl Command {
    pub fn new(program: String) -> Command {
        Command {
            program: program,
            args: Vec::new(),
            cwd: None,
        }
    }

    /// Добавить аргумент
    pub fn arg(&mut self, arg: String) -> &mut Command {
        self.args.push(arg);
        self
    }

    /// Добавить множество аргументов
    pub fn args(&mut self, args: &[String]) -> &mut Command {
        self.args.extend_from_slice(args);
        self
    }

    /// Установить рабочую директорию
    pub fn cwd(&mut self, dir: String) -> &mut Command {
        self.cwd = Some(dir);
        self
    }

    /// Выполнить команду
    pub fn spawn(&self) -> io::Result<Process> {
        /* ... */
    }
}
```

**Использование:**

```rust
let mut cmd = Command::new("/bin/ls");
cmd.arg("-l").arg("-a");
let process = cmd.spawn()?;
```

#### 2. Consuming builders

```rust
pub struct TaskBuilder {
    name: Option<String>,
    stack_size: Option<usize>,
}

impl TaskBuilder {
    /// Установить имя задачи
    pub fn name(mut self, name: String) -> TaskBuilder {
        self.name = Some(name);
        self
    }

    /// Установить размер стека
    pub fn stack_size(mut self, size: usize) -> TaskBuilder {
        self.stack_size = Some(size);
        self
    }

    /// Создать задачу
    pub fn spawn<F>(self, f: F) where F: FnOnce() + Send {
        /* ... */
    }
}
```

**Использование:**

```rust
TaskBuilder::new()
    .name("mytask".to_string())
    .stack_size(10000)
    .spawn(|| { /* ... */ });
```

**Руководство по выбору:**

- Используйте **non-consuming builder**, если builder может быть использован повторно после `build()`
- Используйте **consuming builder**, если конструирование включает побочные эффекты или builder должен быть одноразовым

---

## Dependability - Надежность

### C-VALIDATE: Функции валидируют свои аргументы

Rust API **не следуют принципу надежности** ("будь консервативен в том, что отправляешь; будь либерален в том, что принимаешь"). Вместо этого, код Rust должен обеспечивать валидность входных данных, где практично.

**Механизмы обеспечения (в порядке предпочтения):**

#### 1. Выберите тип аргумента, который исключает плохие входы (статическое обеспечение)

```rust
// Вместо
fn foo(ascii: u8) {
    assert!(ascii <= 127);
    // ...
}

// Используйте newtype
pub struct Ascii(u8);

impl Ascii {
    pub fn new(byte: u8) -> Option<Ascii> {
        if byte <= 127 {
            Some(Ascii(byte))
        } else {
            None
        }
    }
}

fn foo(ascii: Ascii) {
    // Гарантировано валидный ASCII
}
```

**Преимущества:**
- Стоимость переносится к границам (при первом преобразовании)
- Ловит баги рано, во время компиляции
- Мало затрат во время выполнения

#### 2. Валидируйте вход по мере обработки (динамическое обеспечение)

```rust
fn foo(val: usize) -> Result<Bar, Error> {
    if val > MAX_SIZE {
        return Err(Error::TooLarge);
    }
    // ...
}
```

Используется когда свойства сложно или невозможно выразить через типы.

### C-DTOR-FAIL: Деструкторы никогда не падают

Деструкторы выполняются во многих ситуациях:
- Когда значение выходит из области видимости
- Во время раскрутки стека (stack unwinding)
- При вызове `mem::drop`
- etc.

**Panic в деструкторе ведет к аборту процесса**, что нежелательно.

```rust
impl Drop for MyType {
    fn drop(&mut self) {
        // НИКОГДА не паникуйте здесь
        // Обрабатывайте все ошибки gracefully
    }
}
```

### C-DTOR-BLOCK: Деструкторы, которые могут блокироваться, имеют альтернативы

**Деструкторы не должны вызывать блокирующие операции**, что может сделать отладку намного сложнее.

**Если тип нуждается в блокирующей очистке:**

```rust
pub struct Connection {
    // ...
}

impl Connection {
    // Явный метод для блокирующего закрытия
    pub fn close(self) -> Result<(), Error> {
        // Блокирующая очистка здесь
    }
}

impl Drop for Connection {
    fn drop(&mut self) {
        // Неблокирующая очистка или игнорирование ошибок
        let _ = self.try_close();
    }
}
```

**Предоставьте явный метод** для случаев, когда пользователь хочет обработать блокирующую очистку, но также предоставьте Drop impl для удобства.

---

## Debuggability - Отлаживаемость

### C-DEBUG: Все публичные типы реализуют Debug

**Каждый тип, который является частью публичного API вашего крейта, должен реализовывать Debug.**

```rust
#[derive(Debug)]
pub struct MyType {
    // ...
}
```

**Debug критически важен для:**
- Отладки с помощью `println!("{:?}", value)`
- Использования `assert_eq!` и других макросов тестирования
- Отображения в error messages

**Для типов, которые не могут derive Debug:**

```rust
use std::fmt::{self, Debug, Formatter};

impl Debug for MyType {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.debug_struct("MyType")
            .field("field1", &self.field1)
            .field("field2", &self.field2)
            .finish()
    }
}
```

### C-DEBUG-NONEMPTY: Debug представление никогда не пустое

**Debug impl не должен производить пустую строку.**

```rust
// Плохо
impl Debug for Empty {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        Ok(()) // Пустой output
    }
}

// Хорошо
impl Debug for Empty {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.debug_struct("Empty").finish()
    }
}
```

**Пустое Debug представление:**
- Запутывает пользователей
- Усложняет отладку
- Создает неинформативные error messages

---

## Future Proofing - Защита от будущих изменений

### C-SEALED: Sealed трейты защищают от downstream реализаций

**Иногда вы хотите запретить downstream реализации трейта.** Это может быть для:
- Безопасности (небезопасный трейт с инвариантами, которые не могут быть обеспечены пользователями)
- Будущей расширяемости без breaking changes

**Sealed trait pattern:**

```rust
mod private {
    pub trait Sealed {}
}

pub trait MyTrait: private::Sealed {
    // Методы трейта
}

// Только ваш крейт может реализовать Sealed
impl private::Sealed for MyType {}
impl MyTrait for MyType {
    // Реализация
}
```

**Downstream крейты не могут реализовать MyTrait** потому что они не могут реализовать `private::Sealed`.

**Документируйте** в rustdoc, что трейт sealed и не предназначен для реализации вне текущего крейта.

### C-STRUCT-PRIVATE: Структуры имеют приватные поля

**Сделать поле публичным - это сильное обязательство:**
- Фиксирует выбор представления
- Предотвращает валидацию содержимого поля
- Предотвращает поддержание инвариантов

```rust
// Плохо
pub struct User {
    pub id: u64,
    pub name: String,
}

// Хорошо
pub struct User {
    id: u64,
    name: String,
}

impl User {
    pub fn new(id: u64, name: String) -> User {
        User { id, name }
    }

    pub fn id(&self) -> u64 {
        self.id
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn set_name(&mut self, name: String) {
        // Можем добавить валидацию здесь
        self.name = name;
    }
}
```

**Публичные поля наиболее уместны** для struct типов в духе C: составные, пассивные структуры данных.

### C-NEWTYPE-HIDE: Newtypes инкапсулируют детали реализации

**Newtype можно использовать, чтобы скрыть детали представления**, делая точные обещания клиенту.

```rust
// Вместо прямого возврата сложного типа итератора
pub fn my_transform<I>(input: I) -> /* сложный тип */ { /* ... */ }

// Используйте newtype
pub struct MyTransformIter<I> { /* ... */ }

pub fn my_transform<I: Iterator>(input: I) -> MyTransformIter<I> {
    // ...
}
```

**Или используйте impl Trait (Rust 1.26+):**

```rust
pub fn my_transform<I: Iterator>(input: I) -> impl Iterator<Item = (usize, I::Item)> {
    input.skip(3).enumerate()
}
```

**Компромиссы impl Trait:**
- Более лаконично, чем newtype
- Ограничено в том, что можете выразить (например, не можете вернуть итератор, который также impl Debug)
- Хорошо для internal API, может быть для public API в некоторых случаях

### C-STRUCT-BOUNDS: Структуры данных не дублируют derived trait bounds

**Плохо:**

```rust
// Каждый T должен быть Clone, даже если мы никогда не клонируем?
#[derive(Clone)]
pub struct MyStruct<T: Clone> {
    data: T,
}
```

**Хорошо:**

```rust
#[derive(Clone)]
pub struct MyStruct<T> {
    data: T,
}

// Clone автоматически требует T: Clone только при использовании
```

**Исключения, когда bounds оправданны на структуре:**

```rust
// 1. Структура имеет Drop impl, который требует trait bounds
// Rust требует, чтобы все bounds на Drop были также на структуре
pub struct MyStruct<T: SomeTrait> {
    data: T,
}

impl<T: SomeTrait> Drop for MyStruct<T> {
    fn drop(&mut self) { /* ... */ }
}

// 2. Структура ссылается на ассоциированный тип
pub struct MyStruct<T: Iterator> {
    item: T::Item,
}

// 3. Структура оптится из неявного Sized bound
pub struct MyStruct<T: ?Sized> {
    data: Box<T>,
}
```

---

## Necessities - Необходимости

### C-STABLE: Публичные зависимости стабильного крейта стабильны

**Крейт не может быть стабильным (>=1.0.0)** без того, чтобы все его публичные зависимости были стабильны.

**Публичные зависимости** - это крейты, типы из которых используются в публичном API текущего крейта:

```rust
// other_crate должен быть стабильным
pub fn do_my_thing(arg: other_crate::TheirThing) { /* ... */ }
```

**Будьте осторожны**, потому что публичные зависимости могут проскользнуть в неожиданных местах:

```rust
pub struct Error {
    private: ErrorImpl,
}

enum ErrorImpl {
    Io(io::Error),
    
    // О нет! Даже если ErrorImpl приватный,
    // other_crate::Error становится публичной зависимостью
    // через trait объект или другие conversions
    Dep(other_crate::Error),
}
```

### C-PERMISSIVE: Крейт и его зависимости имеют пермиссивную лицензию

**Рекомендуемая лицензия:** MIT OR Apache-2.0 (dual license)

```toml
[package]
name = "..."
version = "..."
license = "MIT OR Apache-2.0"
```

**Создайте файлы:**
- `LICENSE-APACHE` - текст Apache-2.0 лицензии
- `LICENSE-MIT` - текст MIT лицензии

**В README.md:**

```markdown
## License

Licensed under either of

* Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.
```

**Другие пермиссивные лицензии:**
- Одна MIT лицензия
- Одна BSD лицензия

**Не рекомендуется только Apache:** Apache license, хотя и пермиссивная, накладывает ограничения сверх MIT и BSD лицензий, что может препятствовать использованию в некоторых сценариях.

---

## Чеклист для быстрой проверки

### Naming
- [ ] C-CASE: Именование соответствует RFC 430
- [ ] C-CONV: Ad-hoc конверсии используют as_, to_, into_
- [ ] C-GETTER: Геттеры следуют Rust конвенции
- [ ] C-ITER: Методы итераторов: iter, iter_mut, into_iter
- [ ] C-ITER-TY: Имена типов итераторов соответствуют методам
- [ ] C-FEATURE: Имена фич не содержат placeholder слова
- [ ] C-WORD-ORDER: Имена используют последовательный порядок слов

### Interoperability
- [ ] C-COMMON-TRAITS: Типы реализуют общие трейты
- [ ] C-CONV-TRAITS: Конверсии используют From, AsRef, AsMut
- [ ] C-COLLECT: Коллекции реализуют FromIterator и Extend
- [ ] C-SERDE: Структуры данных реализуют Serialize, Deserialize
- [ ] C-SEND-SYNC: Типы Send и Sync где возможно
- [ ] C-GOOD-ERR: Типы ошибок осмысленны и well-behaved
- [ ] C-NUM-FMT: Числовые типы предоставляют Hex, Octal, Binary
- [ ] C-RW-VALUE: Generic reader/writer функции принимают R: Read и W: Write по значению

### Macros
- [ ] C-EVOCATIVE: Входной синтаксис вызывает ассоциации с выходом
- [ ] C-MACRO-ATTR: Макросы хорошо компонуются с атрибутами
- [ ] C-ANYWHERE: Item макросы работают везде где разрешены items
- [ ] C-MACRO-VIS: Item макросы поддерживают спецификаторы видимости
- [ ] C-MACRO-TY: Фрагменты типов гибкие

### Documentation
- [ ] C-CRATE-DOC: Документация уровня крейта тщательна и включает примеры
- [ ] C-EXAMPLE: Все элементы имеют rustdoc пример
- [ ] C-QUESTION-MARK: Примеры используют ?, не try!, не unwrap
- [ ] C-FAILURE: Документация функций включает Error, Panic, Safety секции
- [ ] C-LINK: Проза содержит гиперссылки на соответствующие вещи
- [ ] C-METADATA: Cargo.toml включает все общие метаданные
- [ ] C-RELNOTES: Release notes документируют все значительные изменения
- [ ] C-HIDDEN: Rustdoc не показывает бесполезные детали реализации

### Predictability
- [ ] C-SMART-PTR: Умные указатели не добавляют inherent методы
- [ ] C-CONV-SPECIFIC: Конверсии на наиболее конкретном типе
- [ ] C-METHOD: Функции с четким получателем - это методы
- [ ] C-NO-OUT: Функции не принимают out-параметры
- [ ] C-OVERLOAD: Перегрузки операторов неудивительны
- [ ] C-DEREF: Только умные указатели реализуют Deref и DerefMut
- [ ] C-CTOR: Конструкторы - статические, inherent методы

### Flexibility
- [ ] C-INTERMEDIATE: Функции предоставляют промежуточные результаты
- [ ] C-CALLER-CONTROL: Вызывающий решает где копировать и размещать данные
- [ ] C-GENERIC: Функции минимизируют предположения о параметрах используя generics
- [ ] C-OBJECT: Трейты object-safe если могут быть полезны как trait object

### Type Safety
- [ ] C-NEWTYPE: Newtypes обеспечивают статические различия
- [ ] C-CUSTOM-TYPE: Аргументы передают смысл через типы, не bool или Option
- [ ] C-BITFLAG: Типы для набора флагов - bitflags, не enums
- [ ] C-BUILDER: Билдеры обеспечивают конструирование сложных значений

### Dependability
- [ ] C-VALIDATE: Функции валидируют свои аргументы
- [ ] C-DTOR-FAIL: Деструкторы никогда не падают
- [ ] C-DTOR-BLOCK: Деструкторы которые могут блокироваться имеют альтернативы

### Debuggability
- [ ] C-DEBUG: Все публичные типы реализуют Debug
- [ ] C-DEBUG-NONEMPTY: Debug представление никогда не пустое

### Future Proofing
- [ ] C-SEALED: Sealed трейты защищают от downstream реализаций
- [ ] C-STRUCT-PRIVATE: Структуры имеют приватные поля
- [ ] C-NEWTYPE-HIDE: Newtypes инкапсулируют детали реализации
- [ ] C-STRUCT-BOUNDS: Структуры не дублируют derived trait bounds

### Necessities
- [ ] C-STABLE: Публичные зависимости стабильного крейта стабильны
- [ ] C-PERMISSIVE: Крейт и его зависимости имеют пермиссивную лицензию

---

## Заключение

Эти руководства не являются строгими правилами, но представляют собой накопленную мудрость команды Rust library team. Следование этим рекомендациям поможет создать библиотеки, которые:

- Интуитивно понятны для пользователей
- Хорошо интегрируются с экосистемой Rust
- Легко поддерживаются и расширяются
- Безопасны и надежны
- Хорошо документированы

**Помните:** Эти руководства - инструмент для принятия осознанных решений, а не догма. В каждом случае применяйте их с пониманием контекста вашего конкретного API.

---

**Источники:**
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [RFC 430 - Naming Conventions](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md)
- [RFC 1574 - API Documentation Conventions](https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md)

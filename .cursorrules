{
    "metadata": {
      "name": "Nebula Engineering Rules",
      "version": "0.0.1",
      "description": "Combined Cursor AI + Engineering rules for Nebula workflow engine",
      "msrv": "1.87",
      "priorities": ["correctness", "safety", "observability", "performance", "ergonomics"]
    },
  
    "language": "rust",
  
    "workspace": {
      "structure": {
        "layers": [
          "infrastructure",
          "cross-cutting", 
          "core",
          "node",
          "business-logic",
          "execution",
          "multi-tenancy",
          "developer-tools",
          "presentation"
        ],
        "crate_naming": "nebula-{component}",
        "total_crates": 30
      },
      "dependencies": {
        "runtime": "tokio",
        "async_trait": "0.1",
        "error_handling": "thiserror",
        "serialization": ["serde", "bincode", "rmp-serde"],
        "observability": "tracing",
        "testing": ["tokio-test", "mockall", "criterion"]
      }
    },
  
    "execution": {
      "ci_pipeline": [
        "cargo fmt --all -- --check",
        "cargo clippy --workspace -- -D warnings",
        "cargo check --workspace --all-targets",
        "cargo test --workspace",
        "cargo doc --no-deps --workspace",
        "cargo audit"
      ],
      "local_checks": {
        "pre_commit": "cargo fmt && cargo clippy --fix",
        "test": "cargo test --workspace",
        "bench": "cargo bench --workspace"
      }
    },
  
    "async_rules": {
      "runtime": {
        "use": "tokio only",
        "features": ["full"],
        "spawn": {
          "prefer": "scoped tasks via JoinSet",
          "detached": "only with shutdown handle",
          "always": "capture cancellation paths"
        }
      },
      "patterns": {
        "never_block": "Use spawn_blocking for CPU work",
        "structured_concurrency": "Scoped lifetimes over fire-and-forget",
        "backpressure": "Bounded queues by default",
        "timeouts": "Always at I/O boundaries"
      },
      "channels": {
        "work_queues": "bounded mpsc",
        "events": "broadcast (stateless only)",
        "response": "oneshot",
        "shared_state": "RwLock preferred"
      },
      "example_cancellation": "tokio::select! { _ = do_work() => Ok(()), _ = shutdown.cancelled() => Err(Cancelled) }"
    },
  
    "error_handling": {
      "pattern": "Result<T, E> with thiserror",
      "propagation": "Use ? operator",
      "context": "Add with .context()",
      "boundaries": "Convert external errors",
      "retry_classification": {
        "retryable": ["Transient", "Timeout", "TooManyRequests"],
        "terminal": ["NotFound", "InvalidInput", "PermissionDenied"]
      },
      "example": "#[derive(thiserror::Error)] pub enum ActionError { #[error(\"timeout\")] Timeout }"
    },
  
    "resilience": {
      "timeouts": {
        "default": "30s",
        "database": "5s",
        "http": "10s",
        "pattern": "timeout(DURATION, operation()).await"
      },
      "retries": {
        "strategy": "exponential backoff with jitter",
        "max_attempts": 3,
        "budget": "respect global deadline"
      },
      "circuit_breaker": {
        "failure_threshold": 5,
        "reset_timeout": "60s"
      },
      "bulkheads": "Semaphore-based parallelism limits"
    },
  
    "resource_management": {
      "scopes": {
        "Global": "application lifetime",
        "Workflow": "workflow execution lifetime",
        "Execution": "single execution lifetime",
        "Action": "single action lifetime"
      },
      "patterns": {
        "pools": "for expensive resources",
        "health_checks": "required for all resources",
        "cleanup": "deterministic based on scope"
      },
      "memory": {
        "avoid": "unnecessary clones",
        "prefer": "Arc for sharing",
        "stream": "large payloads"
      }
    },
  
    "observability": {
      "logging": {
        "library": "tracing",
        "levels": {
          "error": "actionable failures",
          "warn": "degradation",
          "info": "lifecycle events",
          "debug": "diagnostics",
          "trace": "hot path (debug only)"
        },
        "required_fields": ["execution_id", "workflow_id", "node_id", "tenant_id"]
      },
      "metrics": {
        "naming": "nebula_{component}_{metric}",
        "types": {
          "counter": "rates",
          "histogram": "latency/size",
          "gauge": "levels"
        }
      },
      "example": "#[tracing::instrument(skip(self), fields(execution_id = %ctx.execution_id))]"
    },
  
    "testing": {
      "async_tests": "#[tokio::test(flavor = \"multi_thread\")]",
      "time_control": "tokio::time::pause() and advance()",
      "deterministic": "no fixed sleeps, use virtual time",
      "mocks": "feature flag test-utils",
      "integration": "ephemeral containers for dependencies"
    },
  
    "security": {
      "secrets": {
        "storage": "SecretString with Zeroize",
        "logging": "never log secrets",
        "rotation": "automatic when possible"
      },
      "validation": "validate all external inputs",
      "credentials": "least-privilege, scoped tokens"
    },
  
    "code_style": {
      "naming": {
        "functions": "snake_case",
        "types": "PascalCase", 
        "constants": "SCREAMING_SNAKE_CASE",
        "booleans": "is_ready, has_data, should_retry"
      },
      "organization": {
        "modules": "small and focused",
        "traits": "narrow interfaces",
        "public_api": "in lib.rs",
        "internals": "in mod/"
      }
    },
  
    "nebula_patterns": {
      "actions": {
        "simple": "SimpleAction for quick impl",
        "derived": "#[derive(Action)] for integration",
        "process": "ProcessAction for complex logic"
      },
      "expressions": {
        "node_ref": "$nodes.{id}.result.{field}",
        "variables": "$workflow.variables.{name}",
        "context": "$user.context.{field}"
      },
      "workflow": {
        "definition": "declarative in nebula-workflow",
        "execution": "runtime in nebula-execution",
        "state": "via ExecutionContext"
      }
    },
  
    "ai_assistant_rules": {
      "response_format": "single rust code block",
      "focus": "implementation over explanation",
      "priorities": [
        "maintain correctness",
        "ensure safety",
        "add observability",
        "optimize performance"
      ],
      "avoid": [
        "fire-and-forget tasks",
        "unbounded channels",
        "blocking in async",
        "silent error swallowing"
      ]
    },
  
    "code_review_checklist": [
      "Ownership and lifetimes correct?",
      "Cancellation handled?",
      "Bounded queues with backpressure?",
      "Structured logs and metrics?",
      "Timeouts and budgeted retries?",
      "No leaked external types in API?",
      "Tests deterministic?",
      "No unnecessary clones?"
    ]
  }
# Nebula Framework - Complete Architecture Documentation
## Part 1: Core Structure & Foundation Layer

> Flutter-inspired declarative UI framework built on egui  
> Version: 0.1.0 | Architecture: Three-Tree Pattern

---

## ğŸ“ Project Structure

```
nebula/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ ARCHITECTURE.md
â”‚
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ nebula_core/              # Core traits & types
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ widget.rs          # Widget trait
â”‚   â”‚       â”œâ”€â”€ element.rs         # Element trait & tree
â”‚   â”‚       â”œâ”€â”€ render_object.rs   # RenderObject trait
â”‚   â”‚       â””â”€â”€ build_context.rs   # BuildContext
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_foundation/        # Foundation layer (Flutter's foundation)
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ key.rs            # Key system
â”‚   â”‚       â”œâ”€â”€ diagnostics.rs    # Debug utilities
â”‚   â”‚       â”œâ”€â”€ change_notifier.rs
â”‚   â”‚       â”œâ”€â”€ listenable.rs
â”‚   â”‚       â”œâ”€â”€ observer_list.rs
â”‚   â”‚       â”œâ”€â”€ platform.rs
â”‚   â”‚       â”œâ”€â”€ assertions.rs
â”‚   â”‚       â”œâ”€â”€ collections.rs
â”‚   â”‚       â””â”€â”€ constants.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_widgets/           # Widget implementations
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ framework/
â”‚   â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ stateful.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ stateless.rs
â”‚   â”‚       â”‚   â””â”€â”€ inherited.rs
â”‚   â”‚       â”œâ”€â”€ basic/
â”‚   â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ container.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ sized_box.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ padding.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ center.rs
â”‚   â”‚       â”‚   â””â”€â”€ align.rs
â”‚   â”‚       â”œâ”€â”€ layout/
â”‚   â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ flex.rs        # Row, Column
â”‚   â”‚       â”‚   â”œâ”€â”€ stack.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ wrap.rs
â”‚   â”‚       â”‚   â””â”€â”€ custom.rs
â”‚   â”‚       â”œâ”€â”€ text/
â”‚   â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ text.rs
â”‚   â”‚       â”‚   â””â”€â”€ rich_text.rs
â”‚   â”‚       â”œâ”€â”€ input/
â”‚   â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ button.rs
â”‚   â”‚       â”‚   â”œâ”€â”€ text_field.rs
â”‚   â”‚       â”‚   â””â”€â”€ checkbox.rs
â”‚   â”‚       â””â”€â”€ scrolling/
â”‚   â”‚           â”œâ”€â”€ mod.rs
â”‚   â”‚           â”œâ”€â”€ scroll_view.rs
â”‚   â”‚           â””â”€â”€ list_view.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_rendering/         # Rendering layer
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ object.rs         # RenderObject impl
â”‚   â”‚       â”œâ”€â”€ box_protocol.rs   # BoxConstraints
â”‚   â”‚       â”œâ”€â”€ flex.rs           # Flex layout
â”‚   â”‚       â”œâ”€â”€ stack.rs          # Stack layout
â”‚   â”‚       â””â”€â”€ proxy_box.rs      # RenderProxyBox
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_painting/          # Painting utilities
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ decoration.rs
â”‚   â”‚       â”œâ”€â”€ edge_insets.rs
â”‚   â”‚       â”œâ”€â”€ alignment.rs
â”‚   â”‚       â”œâ”€â”€ borders.rs
â”‚   â”‚       â””â”€â”€ text_style.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_animation/         # Animation system
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ controller.rs
â”‚   â”‚       â”œâ”€â”€ tween.rs
â”‚   â”‚       â”œâ”€â”€ curves.rs
â”‚   â”‚       â””â”€â”€ transitions.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_gestures/          # Gesture detection
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ recognizer.rs
â”‚   â”‚       â”œâ”€â”€ detector.rs
â”‚   â”‚       â””â”€â”€ events.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ nebula_scheduler/         # Frame scheduling
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ lib.rs
â”‚   â”‚       â”œâ”€â”€ binding.rs
â”‚   â”‚       â”œâ”€â”€ ticker.rs
â”‚   â”‚       â””â”€â”€ priority.rs
â”‚   â”‚
â”‚   â””â”€â”€ nebula_platform/          # Platform integration
â”‚       â”œâ”€â”€ Cargo.toml
â”‚       â””â”€â”€ src/
â”‚           â”œâ”€â”€ lib.rs
â”‚           â”œâ”€â”€ app.rs            # NebulaApp
â”‚           â”œâ”€â”€ window.rs
â”‚           â””â”€â”€ services.rs
â”‚
â”œâ”€â”€ nebula/                       # Main crate (re-exports)
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ lib.rs
â”‚       â””â”€â”€ prelude.rs
â”‚
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ counter.rs
â”‚   â”œâ”€â”€ layout_demo.rs
â”‚   â”œâ”€â”€ animation_demo.rs
â”‚   â””â”€â”€ node_editor.rs
â”‚
â””â”€â”€ benches/
    â””â”€â”€ widget_bench.rs
```

---

## ğŸ—ï¸ Three-Tree Architecture

### Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Widget Tree                          â”‚
â”‚              (Immutable Configuration)                  â”‚
â”‚                                                         â”‚
â”‚  MyApp                                                  â”‚
â”‚    â””â”€ Container                                         â”‚
â”‚         â””â”€ Column                                       â”‚
â”‚              â”œâ”€ Text("Hello")                          â”‚
â”‚              â””â”€ Button("Click")                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“ createElement()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Element Tree                          â”‚
â”‚                 (Mutable State Holder)                  â”‚
â”‚                                                         â”‚
â”‚  ComponentElement<MyApp>                                â”‚
â”‚    â””â”€ SingleChildElement<Container>                     â”‚
â”‚         â””â”€ MultiChildElement<Column>                    â”‚
â”‚              â”œâ”€ LeafElement<Text>                      â”‚
â”‚              â””â”€ LeafElement<Button>                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“ createRenderObject()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Render Tree                           â”‚
â”‚                (Layout & Paint Logic)                   â”‚
â”‚                                                         â”‚
â”‚  RenderView                                             â”‚
â”‚    â””â”€ RenderConstrainedBox                              â”‚
â”‚         â””â”€ RenderFlex                                   â”‚
â”‚              â”œâ”€ RenderParagraph                        â”‚
â”‚              â””â”€ RenderPointerListener                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“ paint()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 egui::Painter                           â”‚
â”‚              (Immediate Mode Rendering)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Foundation Layer (nebula_foundation)

### Key System (`key.rs`)

```rust
// Core Key trait
pub trait Key: Any + Debug + Send + Sync {
    fn equals(&self, other: &dyn Key) -> bool;
    fn hash_code(&self) -> u64;
    fn as_any(&self) -> &dyn Any;
}

// LocalKey - scoped to parent
pub trait LocalKey: Key {}

// ValueKey<T> - identified by value
#[derive(Debug, Clone)]
pub struct ValueKey<T: Hash + Eq + Clone + Send + Sync + 'static> {
    value: T,
}

// UniqueKey - always unique
pub struct UniqueKey {
    id: u64, // Generated atomically
}

// ObjectKey - identified by pointer
pub struct ObjectKey<T: 'static> {
    ptr: *const T,
}

// GlobalKey<T> - can access state from anywhere
pub struct GlobalKey<T: 'static> {
    id: GlobalKeyId,
    _phantom: PhantomData<T>,
}

impl<T> GlobalKey<T> {
    pub fn current_state(&self) -> Option<&T>;
    pub fn current_context(&self) -> Option<BuildContext>;
}
```

**Usage:**
```rust
// In widget
let key = ValueKey::new("my-widget");
let global = GlobalKey::<CounterState>::new();

// Access from anywhere
if let Some(state) = global.current_state() {
    state.increment();
}
```

### Diagnostics (`diagnostics.rs`)

```rust
// Diagnosticable trait
pub trait Diagnosticable {
    fn to_string_short(&self) -> String;
    fn to_string_deep(&self) -> String;
    fn debug_fill_properties(&self, props: &mut DiagnosticPropertiesBuilder);
}

// DiagnosticsNode - debug info
pub enum DiagnosticsNode {
    StringProperty { name: String, value: String },
    IntProperty { name: String, value: i64 },
    FlagProperty { name: String, shown: bool },
}

// Builder for diagnostics
pub struct DiagnosticPropertiesBuilder {
    properties: Vec<DiagnosticsNode>,
}
```

### ChangeNotifier & Listenable (`change_notifier.rs`)

```rust
// Listenable - base observable trait
pub trait Listenable {
    fn add_listener(&mut self, listener: VoidCallback) -> ListenerId;
    fn remove_listener(&mut self, id: ListenerId);
    fn notify_listeners(&self);
}

// ChangeNotifier - simple observable
pub struct ChangeNotifier {
    listeners: ObserverList<VoidCallback>,
}

// ValueNotifier<T> - observable value
pub struct ValueNotifier<T: Clone> {
    value: T,
    notifier: ChangeNotifier,
}

impl<T: Clone> ValueNotifier<T> {
    pub fn new(value: T) -> Self;
    pub fn value(&self) -> &T;
    pub fn set_value(&mut self, value: T); // Auto-notifies
}

// ValueListenable<T> - read-only observable
pub trait ValueListenable<T>: Listenable {
    fn value(&self) -> &T;
}
```

### ObserverList (`observer_list.rs`)

```rust
// Optimized for small number of observers
pub struct ObserverList<T> {
    observers: Vec<(ListenerId, T)>,
}

// Optimized for large number of observers
pub struct HashedObserverList<T> {
    observers: HashMap<ListenerId, T>,
}

impl<T> ObserverList<T> {
    pub fn new() -> Self;
    pub fn add(&mut self, observer: T) -> ListenerId;
    pub fn remove(&mut self, id: ListenerId);
    pub fn is_empty(&self) -> bool;
    pub fn iter(&self) -> impl Iterator<Item = &T>;
}
```

### Platform Detection (`platform.rs`)

```rust
// Debug/Release mode
pub const K_DEBUG_MODE: bool = cfg!(debug_assertions);
pub const K_RELEASE_MODE: bool = !cfg!(debug_assertions);

// Platform
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TargetPlatform {
    Android, iOS, Linux, MacOS, Windows, Web,
}

pub fn default_target_platform() -> TargetPlatform {
    #[cfg(target_os = "windows")]
    return TargetPlatform::Windows;
    // ... other platforms
}

// Brightness
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Brightness { Light, Dark }
```

### Assertions & Errors (`assertions.rs`)

```rust
// FlutterError - structured error
#[derive(Debug)]
pub struct FlutterError {
    pub summary: ErrorSummary,
    pub description: Vec<ErrorDescription>,
    pub hints: Vec<ErrorHint>,
    pub stack_trace: Option<Backtrace>,
}

impl FlutterError {
    pub fn new(summary: impl Into<String>) -> Self;
    pub fn with_description(self, desc: impl Into<String>) -> Self;
    pub fn with_hint(self, hint: impl Into<String>) -> Self;
    pub fn report(self);
}

// Usage
FlutterError::new("Widget not found")
    .with_description("Counter widget was disposed")
    .with_hint("Check widget lifecycle")
    .report();
```

### Type Aliases (`lib.rs`)

```rust
// Callback types
pub type VoidCallback = Box<dyn Fn() + Send + Sync>;
pub type AsyncCallback = Box<dyn Fn() -> BoxFuture<'static, ()> + Send + Sync>;
pub type ValueChanged<T> = Box<dyn Fn(T) + Send + Sync>;
pub type ValueGetter<T> = Box<dyn Fn() -> T + Send + Sync>;
pub type ValueSetter<T> = Box<dyn Fn(T) + Send + Sync>;

// Common types
pub type ListenerId = u64;
```

---

## ğŸ“¦ Dependencies (Cargo.toml)

### Main Workspace
```toml
[workspace]
members = [
    "crates/nebula_core",
    "crates/nebula_foundation",
    "crates/nebula_widgets",
    "crates/nebula_rendering",
    "crates/nebula_painting",
    "crates/nebula_animation",
    "crates/nebula_gestures",
    "crates/nebula_scheduler",
    "crates/nebula_platform",
    "nebula",
]
resolver = "2"

[workspace.dependencies]
egui = "0.29"
eframe = "0.29"
bon = "2.3"
```

### nebula_foundation/Cargo.toml
```toml
[package]
name = "nebula_foundation"
version = "0.1.0"
edition = "2021"

[dependencies]
# No dependencies - pure Rust
```

### nebula_core/Cargo.toml
```toml
[package]
name = "nebula_core"
version = "0.1.0"
edition = "2021"

[dependencies]
nebula_foundation = { path = "../nebula_foundation" }
```

---

## ğŸ¨ Design Principles

### 1. Separation of Concerns
- **Widget**: Immutable configuration (what to show)
- **Element**: Mutable state holder (lifecycle management)
- **RenderObject**: Layout & paint (how to draw)

### 2. Performance Strategy
- Elements prevent unnecessary rebuilds
- Keys enable efficient list updates
- RenderObjects cache layout results
- egui handles actual rendering

### 3. Type Safety
- Strong typing prevents errors at compile time
- Trait objects for polymorphism
- Builder pattern for ergonomic APIs

### 4. Developer Experience
- Declarative API (Flutter-like)
- Hot-reload friendly (via keys)
- Comprehensive diagnostics
- Clear error messages

---

**Next:** Part 2 - Core Traits & Widget System

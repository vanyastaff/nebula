# üî• –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ —É—Å–ª–æ–≤–Ω—ã—Ö –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤

## üìã –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ
1. [–£–ª—É—á—à–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–Ω—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã](#—É–ª—É—á—à–µ–Ω–Ω—ã–µ-—É—Å–ª–æ–≤–Ω—ã–µ-–≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã)
2. [–ö–æ–º–ø–æ–∑–∏—Ü–∏—è –ø—Ä–∞–≤–∏–ª](#–∫–æ–º–ø–æ–∑–∏—Ü–∏—è-–ø—Ä–∞–≤–∏–ª)
3. [–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è](#–∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º–∞—è-–≤–∞–ª–∏–¥–∞—Ü–∏—è)
4. [–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –ø—Ä–∞–≤–∏–ª–∞](#–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ-–ø—Ä–∞–≤–∏–ª–∞)
5. [–ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è](#–ø—Ä–∏–º–µ—Ä—ã-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)

## –£–ª—É—á—à–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–Ω—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã

### 1. **–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π When –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ —É—Å–ª–æ–≤–∏—è–º–∏**

```rust
// nebula-validator/src/validators/conditional/when.rs

use std::fmt::Debug;
use async_trait::async_trait;
use serde_json::Value;

/// –£—Å–ª–æ–≤–∏–µ –¥–ª—è When –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞
pub trait Condition: Send + Sync + Debug {
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —É—Å–ª–æ–≤–∏–µ
    async fn evaluate(&self, value: &Value, context: &ValidationContext) -> bool;
    
    /// –ü–æ–ª—É—á–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ —É—Å–ª–æ–≤–∏—è
    fn describe(&self) -> String;
}

/// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π When –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Å–ª–æ–∂–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
pub struct When<C, T, F> {
    condition: C,
    then_validator: T,
    else_validator: Option<F>,
    mode: WhenMode,
}

#[derive(Debug, Clone, Copy)]
pub enum WhenMode {
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ
    Simple,
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å then –µ—Å–ª–∏ –∏—Å—Ç–∏–Ω–Ω–æ, else –µ—Å–ª–∏ –ª–æ–∂–Ω–æ
    IfElse,
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
    Switch,
}

impl<C, T, F> When<C, T, F> 
where
    C: Condition,
    T: Validatable,
    F: Validatable,
{
    /// –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π When –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub fn new(condition: C, then_validator: T) -> Self {
        Self {
            condition,
            then_validator,
            else_validator: None,
            mode: WhenMode::Simple,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å else –≤–µ—Ç–∫—É
    pub fn otherwise(mut self, else_validator: F) -> Self {
        self.else_validator = Some(else_validator);
        self.mode = WhenMode::IfElse;
        self
    }
    
    /// –°–æ–∑–¥–∞—Ç—å —Ü–µ–ø–æ—á–∫—É When –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤
    pub fn and_when<C2, T2>(self, condition: C2, validator: T2) -> WhenChain {
        WhenChain::new()
            .when(self.condition, self.then_validator)
            .when(condition, validator)
    }
}

/// –¶–µ–ø–æ—á–∫–∞ When —É—Å–ª–æ–≤–∏–π (–∞–Ω–∞–ª–æ–≥ switch/case)
pub struct WhenChain {
    cases: Vec<WhenCase>,
    default: Option<Box<dyn Validatable>>,
}

struct WhenCase {
    condition: Box<dyn Condition>,
    validator: Box<dyn Validatable>,
    stop_on_match: bool,
}

impl WhenChain {
    pub fn new() -> Self {
        Self {
            cases: Vec::new(),
            default: None,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å —É—Å–ª–æ–≤–∏–µ
    pub fn when<C, V>(mut self, condition: C, validator: V) -> Self 
    where
        C: Condition + 'static,
        V: Validatable + 'static,
    {
        self.cases.push(WhenCase {
            condition: Box::new(condition),
            validator: Box::new(validator),
            stop_on_match: true,
        });
        self
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å —É—Å–ª–æ–≤–∏–µ –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ü–µ–ø–æ—á–∫—É
    pub fn also_when<C, V>(mut self, condition: C, validator: V) -> Self
    where
        C: Condition + 'static,
        V: Validatable + 'static,
    {
        self.cases.push(WhenCase {
            condition: Box::new(condition),
            validator: Box::new(validator),
            stop_on_match: false,
        });
        self
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    pub fn otherwise<V>(mut self, validator: V) -> Self
    where
        V: Validatable + 'static,
    {
        self.default = Some(Box::new(validator));
        self
    }
}

#[async_trait]
impl Validatable for WhenChain {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let context = ValidationContext::new();
        let mut matched = false;
        let mut errors = Vec::new();
        
        for case in &self.cases {
            if case.condition.evaluate(value, &context).await {
                matched = true;
                match case.validator.validate(value).await {
                    Ok(_) => {},
                    Err(e) => errors.push(e),
                }
                
                if case.stop_on_match {
                    break;
                }
            }
        }
        
        // –ï—Å–ª–∏ –Ω–∏ –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ, –ø—Ä–∏–º–µ–Ω–∏—Ç—å default
        if !matched {
            if let Some(ref default_validator) = self.default {
                match default_validator.validate(value).await {
                    Ok(_) => {},
                    Err(e) => errors.push(e),
                }
            }
        }
        
        if errors.is_empty() {
            ValidationResult::success(())
        } else {
            ValidationResult::failure(errors)
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "when_chain",
            "Conditional validation chain",
            ValidatorCategory::Conditional,
        )
    }
}
```

### 2. **–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è When**

```rust
// nebula-validator/src/validators/conditional/conditions.rs

/// –£—Å–ª–æ–≤–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–ª—è
#[derive(Debug, Clone)]
pub struct FieldCondition {
    field_path: String,
    predicate: FieldPredicate,
}

#[derive(Debug, Clone)]
pub enum FieldPredicate {
    /// –ü–æ–ª–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    Exists,
    /// –ü–æ–ª–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    NotExists,
    /// –ü–æ–ª–µ —Ä–∞–≤–Ω–æ –∑–Ω–∞—á–µ–Ω–∏—é
    Equals(Value),
    /// –ü–æ–ª–µ –Ω–µ —Ä–∞–≤–Ω–æ –∑–Ω–∞—á–µ–Ω–∏—é
    NotEquals(Value),
    /// –ü–æ–ª–µ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ
    In(Vec<Value>),
    /// –ü–æ–ª–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ
    NotIn(Vec<Value>),
    /// –ü–æ–ª–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—É
    Matches(String),
    /// –ü–æ–ª–µ –±–æ–ª—å—à–µ –∑–Ω–∞—á–µ–Ω–∏—è
    GreaterThan(Value),
    /// –ü–æ–ª–µ –º–µ–Ω—å—à–µ –∑–Ω–∞—á–µ–Ω–∏—è
    LessThan(Value),
    /// –ü–æ–ª–µ –º–µ–∂–¥—É –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    Between(Value, Value),
    /// –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç
    Custom(Box<dyn Fn(&Value) -> bool + Send + Sync>),
}

#[async_trait]
impl Condition for FieldCondition {
    async fn evaluate(&self, value: &Value, _context: &ValidationContext) -> bool {
        let field_value = self.get_field_value(value);
        
        match &self.predicate {
            FieldPredicate::Exists => field_value.is_some(),
            FieldPredicate::NotExists => field_value.is_none(),
            FieldPredicate::Equals(expected) => {
                field_value.map_or(false, |v| v == expected)
            },
            FieldPredicate::NotEquals(expected) => {
                field_value.map_or(true, |v| v != expected)
            },
            FieldPredicate::In(values) => {
                field_value.map_or(false, |v| values.contains(v))
            },
            FieldPredicate::NotIn(values) => {
                field_value.map_or(true, |v| !values.contains(v))
            },
            FieldPredicate::Matches(pattern) => {
                if let Some(Value::String(s)) = field_value {
                    regex::Regex::new(pattern).ok()
                        .map_or(false, |re| re.is_match(s))
                } else {
                    false
                }
            },
            FieldPredicate::GreaterThan(threshold) => {
                field_value.map_or(false, |v| {
                    compare_values(v, threshold, Ordering::Greater)
                })
            },
            FieldPredicate::LessThan(threshold) => {
                field_value.map_or(false, |v| {
                    compare_values(v, threshold, Ordering::Less)
                })
            },
            FieldPredicate::Between(min, max) => {
                field_value.map_or(false, |v| {
                    compare_values(v, min, Ordering::Greater) &&
                    compare_values(v, max, Ordering::Less)
                })
            },
            FieldPredicate::Custom(predicate) => {
                field_value.map_or(false, |v| predicate(v))
            },
        }
    }
    
    fn describe(&self) -> String {
        format!("Field '{}' {:?}", self.field_path, self.predicate)
    }
}

/// –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
#[derive(Debug)]
pub enum CombinedCondition {
    /// –í—Å–µ —É—Å–ª–æ–≤–∏—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏—Å—Ç–∏–Ω–Ω—ã
    All(Vec<Box<dyn Condition>>),
    /// –•–æ—Ç—è –±—ã –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∏—Å—Ç–∏–Ω–Ω–æ
    Any(Vec<Box<dyn Condition>>),
    /// –ù–∏ –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∏—Å—Ç–∏–Ω–Ω–æ
    None(Vec<Box<dyn Condition>>),
    /// –ò–Ω–≤–µ—Ä—Å–∏—è —É—Å–ª–æ–≤–∏—è
    Not(Box<dyn Condition>),
}

#[async_trait]
impl Condition for CombinedCondition {
    async fn evaluate(&self, value: &Value, context: &ValidationContext) -> bool {
        match self {
            Self::All(conditions) => {
                for condition in conditions {
                    if !condition.evaluate(value, context).await {
                        return false;
                    }
                }
                true
            },
            Self::Any(conditions) => {
                for condition in conditions {
                    if condition.evaluate(value, context).await {
                        return true;
                    }
                }
                false
            },
            Self::None(conditions) => {
                for condition in conditions {
                    if condition.evaluate(value, context).await {
                        return false;
                    }
                }
                true
            },
            Self::Not(condition) => {
                !condition.evaluate(value, context).await
            },
        }
    }
    
    fn describe(&self) -> String {
        match self {
            Self::All(_) => "All conditions".to_string(),
            Self::Any(_) => "Any condition".to_string(),
            Self::None(_) => "No conditions".to_string(),
            Self::Not(c) => format!("Not {}", c.describe()),
        }
    }
}
```

### 3. **–£–ª—É—á—à–µ–Ω–Ω—ã–µ Required/Optional –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã**

```rust
// nebula-validator/src/validators/conditional/required.rs

/// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π Required –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å —É—Å–ª–æ–≤–∏—è–º–∏
pub struct Required {
    mode: RequiredMode,
    conditions: Vec<Box<dyn Condition>>,
    custom_message: Option<String>,
}

#[derive(Debug, Clone)]
pub enum RequiredMode {
    /// –í—Å–µ–≥–¥–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ
    Always,
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ
    If(Box<dyn Condition>),
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ –ª—é–±–æ–µ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ
    IfAny(Vec<Box<dyn Condition>>),
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ –≤—Å–µ —É—Å–ª–æ–≤–∏—è –∏—Å—Ç–∏–Ω–Ω—ã
    IfAll(Vec<Box<dyn Condition>>),
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ –¥—Ä—É–≥–æ–µ –ø–æ–ª–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    IfFieldExists(String),
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ –¥—Ä—É–≥–æ–µ –ø–æ–ª–µ –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ
    IfFieldEquals(String, Value),
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≥—Ä—É–ø–ø—ã
    Group(String),
}

impl Required {
    /// –°–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π Required –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub fn new() -> Self {
        Self {
            mode: RequiredMode::Always,
            conditions: Vec::new(),
            custom_message: None,
        }
    }
    
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ
    pub fn if_condition<C: Condition + 'static>(mut self, condition: C) -> Self {
        self.mode = RequiredMode::If(Box::new(condition));
        self
    }
    
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ –ø–æ–ª–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    pub fn if_field_exists(mut self, field: impl Into<String>) -> Self {
        self.mode = RequiredMode::IfFieldExists(field.into());
        self
    }
    
    /// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –µ—Å–ª–∏ –ø–æ–ª–µ —Ä–∞–≤–Ω–æ –∑–Ω–∞—á–µ–Ω–∏—é
    pub fn if_field_equals(mut self, field: impl Into<String>, value: Value) -> Self {
        self.mode = RequiredMode::IfFieldEquals(field.into(), value);
        self
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    pub fn with_message(mut self, message: impl Into<String>) -> Self {
        self.custom_message = Some(message.into());
        self
    }
}

/// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π Optional –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
pub struct Optional<V> {
    validator: V,
    apply_when: OptionalMode,
    default_value: Option<Value>,
    transform: Option<Box<dyn Fn(Value) -> Value + Send + Sync>>,
}

#[derive(Debug, Clone)]
pub enum OptionalMode {
    /// –í—Å–µ–≥–¥–∞ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
    Always,
    /// –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    IfPresent,
    /// –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ null
    IfNotNull,
    /// –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –ø—É—Å—Ç–æ–µ
    IfNotEmpty,
    /// –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Å —É—Å–ª–æ–≤–∏–µ–º
    IfCondition(Box<dyn Condition>),
}

impl<V: Validatable> Optional<V> {
    /// –°–æ–∑–¥–∞—Ç—å Optional –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub fn new(validator: V) -> Self {
        Self {
            validator,
            apply_when: OptionalMode::IfPresent,
            default_value: None,
            transform: None,
        }
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    pub fn with_default(mut self, value: Value) -> Self {
        self.default_value = Some(value);
        self
    }
    
    /// –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
    pub fn transform<F>(mut self, f: F) -> Self 
    where
        F: Fn(Value) -> Value + Send + Sync + 'static,
    {
        self.transform = Some(Box::new(f));
        self
    }
    
    /// –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ
    pub fn when<C: Condition + 'static>(mut self, condition: C) -> Self {
        self.apply_when = OptionalMode::IfCondition(Box::new(condition));
        self
    }
}

#[async_trait]
impl<V: Validatable> Validatable for Optional<V> {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let should_validate = match &self.apply_when {
            OptionalMode::Always => true,
            OptionalMode::IfPresent => !value.is_null(),
            OptionalMode::IfNotNull => !value.is_null(),
            OptionalMode::IfNotEmpty => {
                match value {
                    Value::String(s) => !s.is_empty(),
                    Value::Array(a) => !a.is_empty(),
                    Value::Object(o) => !o.is_empty(),
                    Value::Null => false,
                    _ => true,
                }
            },
            OptionalMode::IfCondition(condition) => {
                let context = ValidationContext::new();
                condition.evaluate(value, &context).await
            },
        };
        
        if should_validate {
            let value_to_validate = if let Some(ref transform) = self.transform {
                transform(value.clone())
            } else {
                value.clone()
            };
            
            self.validator.validate(&value_to_validate).await
        } else if value.is_null() && self.default_value.is_some() {
            // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            ValidationResult::success(())
        } else {
            ValidationResult::success(())
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "optional",
            "Optional validator",
            ValidatorCategory::Conditional,
        )
    }
}
```

### 4. **–£–ª—É—á—à–µ–Ω–Ω—ã–µ OR/AND/XOR –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã**

```rust
// nebula-validator/src/validators/logical/advanced.rs

/// –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π OR –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –≤–µ—Å–∞–º–∏ –∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏
pub struct WeightedOr {
    validators: Vec<WeightedValidator>,
    min_weight: f64,
    short_circuit: bool,
}

struct WeightedValidator {
    validator: Box<dyn Validatable>,
    weight: f64,
    priority: u8,
}

impl WeightedOr {
    pub fn new() -> Self {
        Self {
            validators: Vec::new(),
            min_weight: 1.0,
            short_circuit: true,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –≤–µ—Å–æ–º
    pub fn add<V: Validatable + 'static>(mut self, validator: V, weight: f64) -> Self {
        self.validators.push(WeightedValidator {
            validator: Box::new(validator),
            weight,
            priority: 0,
        });
        self
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –≤–µ—Å–æ–º –∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
    pub fn add_with_priority<V: Validatable + 'static>(
        mut self, 
        validator: V, 
        weight: f64,
        priority: u8
    ) -> Self {
        self.validators.push(WeightedValidator {
            validator: Box::new(validator),
            weight,
            priority,
        });
        self
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤–µ—Å –¥–ª—è —É—Å–ø–µ—Ö–∞
    pub fn min_weight(mut self, weight: f64) -> Self {
        self.min_weight = weight;
        self
    }
    
    /// –û—Ç–∫–ª—é—á–∏—Ç—å short-circuit evaluation
    pub fn no_short_circuit(mut self) -> Self {
        self.short_circuit = false;
        self
    }
}

#[async_trait]
impl Validatable for WeightedOr {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        // –°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
        let mut sorted_validators = self.validators.clone();
        sorted_validators.sort_by_key(|v| v.priority);
        
        let mut total_weight = 0.0;
        let mut errors = Vec::new();
        
        for weighted in &sorted_validators {
            match weighted.validator.validate(value).await {
                Ok(_) => {
                    total_weight += weighted.weight;
                    if self.short_circuit && total_weight >= self.min_weight {
                        return ValidationResult::success(());
                    }
                },
                Err(e) => errors.push(e),
            }
        }
        
        if total_weight >= self.min_weight {
            ValidationResult::success(())
        } else {
            ValidationResult::failure(errors)
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "weighted_or",
            "Weighted OR validator",
            ValidatorCategory::Logical,
        )
    }
}

/// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π AND –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º
pub struct ParallelAnd {
    validators: Vec<Box<dyn Validatable>>,
    max_concurrency: usize,
    fail_fast: bool,
    collect_all_errors: bool,
}

impl ParallelAnd {
    pub fn new() -> Self {
        Self {
            validators: Vec::new(),
            max_concurrency: 10,
            fail_fast: false,
            collect_all_errors: true,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub fn add<V: Validatable + 'static>(mut self, validator: V) -> Self {
        self.validators.push(Box::new(validator));
        self
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å
    pub fn max_concurrency(mut self, max: usize) -> Self {
        self.max_concurrency = max;
        self
    }
    
    /// –í–∫–ª—é—á–∏—Ç—å fail-fast —Ä–µ–∂–∏–º
    pub fn fail_fast(mut self) -> Self {
        self.fail_fast = true;
        self
    }
}

#[async_trait]
impl Validatable for ParallelAnd {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        use futures::stream::{self, StreamExt};
        
        let semaphore = Arc::new(Semaphore::new(self.max_concurrency));
        let value = Arc::new(value.clone());
        
        let futures = self.validators.iter().map(|validator| {
            let sem = semaphore.clone();
            let val = value.clone();
            let validator = validator.clone();
            
            async move {
                let _permit = sem.acquire().await.unwrap();
                validator.validate(&val).await
            }
        });
        
        if self.fail_fast {
            // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –Ω–∞ –ø–µ—Ä–≤–æ–π –æ—à–∏–±–∫–µ
            let mut stream = stream::iter(futures).buffer_unordered(self.max_concurrency);
            while let Some(result) = stream.next().await {
                if let Err(e) = result {
                    return Err(e);
                }
            }
            Ok(())
        } else {
            // –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –æ—à–∏–±–∫–∏
            let results: Vec<_> = stream::iter(futures)
                .buffer_unordered(self.max_concurrency)
                .collect()
                .await;
            
            let errors: Vec<_> = results.into_iter()
                .filter_map(|r| r.err())
                .collect();
            
            if errors.is_empty() {
                ValidationResult::success(())
            } else {
                ValidationResult::failure(errors)
            }
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "parallel_and",
            "Parallel AND validator",
            ValidatorCategory::Logical,
        )
    }
}

/// XOR –≤–∞–ª–∏–¥–∞—Ç–æ—Ä - —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–π—Ç–∏
pub struct Xor {
    validators: Vec<Box<dyn Validatable>>,
    expected_count: XorExpectation,
}

#[derive(Debug, Clone)]
pub enum XorExpectation {
    /// –†–æ–≤–Ω–æ –æ–¥–∏–Ω –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–π—Ç–∏
    ExactlyOne,
    /// –†–æ–≤–Ω–æ N –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ –¥–æ–ª–∂–Ω—ã –ø—Ä–æ–π—Ç–∏
    Exactly(usize),
    /// –ù–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–π—Ç–∏
    Odd,
    /// –ß–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–π—Ç–∏
    Even,
}

impl Xor {
    pub fn new() -> Self {
        Self {
            validators: Vec::new(),
            expected_count: XorExpectation::ExactlyOne,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub fn add<V: Validatable + 'static>(mut self, validator: V) -> Self {
        self.validators.push(Box::new(validator));
        self
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ–∂–∏–¥–∞–Ω–∏–µ
    pub fn expect(mut self, expectation: XorExpectation) -> Self {
        self.expected_count = expectation;
        self
    }
}

#[async_trait]
impl Validatable for Xor {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let mut success_count = 0;
        let mut errors = Vec::new();
        
        for validator in &self.validators {
            match validator.validate(value).await {
                Ok(_) => success_count += 1,
                Err(e) => errors.push(e),
            }
        }
        
        let is_valid = match self.expected_count {
            XorExpectation::ExactlyOne => success_count == 1,
            XorExpectation::Exactly(n) => success_count == n,
            XorExpectation::Odd => success_count % 2 == 1,
            XorExpectation::Even => success_count % 2 == 0,
        };
        
        if is_valid {
            ValidationResult::success(())
        } else {
            let error = ValidationError::new(
                ErrorCode::XorValidationFailed,
                format!("XOR validation failed: {} validators passed, expected {:?}",
                    success_count, self.expected_count)
            );
            ValidationResult::failure(vec![error])
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "xor",
            "XOR validator",
            ValidatorCategory::Logical,
        )
    }
}
```

### 5. **–°–∏—Å—Ç–µ–º–∞ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–∞–≤–∏–ª**

```rust
// nebula-validator/src/validators/composition.rs

/// Builder –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª
pub struct RuleComposer {
    rules: Vec<ComposedRule>,
    context: ValidationContext,
}

pub struct ComposedRule {
    id: String,
    validator: Box<dyn Validatable>,
    dependencies: Vec<String>,
    priority: i32,
    cache_result: bool,
}

impl RuleComposer {
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            context: ValidationContext::new(),
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–∞–≤–∏–ª–æ
    pub fn rule<V: Validatable + 'static>(
        mut self,
        id: impl Into<String>,
        validator: V,
    ) -> Self {
        self.rules.push(ComposedRule {
            id: id.into(),
            validator: Box::new(validator),
            dependencies: Vec::new(),
            priority: 0,
            cache_result: false,
        });
        self
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–∞–≤–∏–ª–æ —Å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏
    pub fn dependent_rule<V: Validatable + 'static>(
        mut self,
        id: impl Into<String>,
        validator: V,
        dependencies: Vec<String>,
    ) -> Self {
        self.rules.push(ComposedRule {
            id: id.into(),
            validator: Box::new(validator),
            dependencies,
            priority: 0,
            cache_result: false,
        });
        self
    }
    
    /// –°–æ–∑–¥–∞—Ç—å –≥—Ä–∞—Ñ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é
    pub async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let execution_order = self.topological_sort()?;
        let mut results = HashMap::new();
        let mut errors = Vec::new();
        
        for rule_id in execution_order {
            let rule = self.rules.iter()
                .find(|r| r.id == rule_id)
                .unwrap();
            
            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            let deps_satisfied = rule.dependencies.iter()
                .all(|dep| results.get(dep).map_or(false, |r: &bool| *r));
            
            if !deps_satisfied {
                continue; // –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –µ—Å–ª–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã
            }
            
            match rule.validator.validate(value).await {
                Ok(_) => {
                    results.insert(rule.id.clone(), true);
                },
                Err(e) => {
                    results.insert(rule.id.clone(), false);
                    errors.push(e);
                }
            }
        }
        
        if errors.is_empty() {
            ValidationResult::success(())
        } else {
            ValidationResult::failure(errors)
        }
    }
    
    /// –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    fn topological_sort(&self) -> Result<Vec<String>, ValidationError> {
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ö–∞–Ω–∞
        let mut in_degree = HashMap::new();
        let mut graph = HashMap::new();
        
        // –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ
        for rule in &self.rules {
            in_degree.entry(rule.id.clone()).or_insert(0);
            graph.entry(rule.id.clone()).or_insert_with(Vec::new);
            
            for dep in &rule.dependencies {
                graph.entry(dep.clone())
                    .or_insert_with(Vec::new)
                    .push(rule.id.clone());
                *in_degree.entry(rule.id.clone()).or_insert(0) += 1;
            }
        }
        
        // –ù–∞–π—Ç–∏ —É–∑–ª—ã –±–µ–∑ –≤—Ö–æ–¥—è—â–∏—Ö —Ä–µ–±–µ—Ä
        let mut queue = VecDeque::new();
        for (node, &degree) in &in_degree {
            if degree == 0 {
                queue.push_back(node.clone());
            }
        }
        
        let mut result = Vec::new();
        while let Some(node) = queue.pop_front() {
            result.push(node.clone());
            
            if let Some(neighbors) = graph.get(&node) {
                for neighbor in neighbors {
                    let degree = in_degree.get_mut(neighbor).unwrap();
                    *degree -= 1;
                    if *degree == 0 {
                        queue.push_back(neighbor.clone());
                    }
                }
            }
        }
        
        if result.len() != self.rules.len() {
            Err(ValidationError::new(
                ErrorCode::CircularDependency,
                "Circular dependency detected in validation rules"
            ))
        } else {
            Ok(result)
        }
    }
}
```

## –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

### –ü—Ä–∏–º–µ—Ä 1: –°–ª–æ–∂–Ω–∞—è —É—Å–ª–æ–≤–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º—ã

```rust
use nebula_validator::prelude::*;

// –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º—ã —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
let registration_validator = RuleComposer::new()
    // –ë–∞–∑–æ–≤—ã–µ –ø–æ–ª—è –≤—Å–µ–≥–¥–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
    .rule("username", 
        Required::new()
            .and(StringLength::new(3, 20))
            .and(Pattern::new(r"^[a-zA-Z0-9_]+$"))
    )
    .rule("email",
        Required::new()
            .and(Email::new())
    )
    .rule("password",
        Required::new()
            .and(StringLength::min(8))
            .and(PasswordStrength::medium())
    )
    
    // –£—Å–ª–æ–≤–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∞–∫–∫–∞—É–Ω—Ç–∞
    .rule("account_type_validation",
        WhenChain::new()
            .when(
                field("account_type").equals("business"),
                All::new(vec![
                    Required::new().for_field("company_name"),
                    Required::new().for_field("tax_id"),
                    Optional::new(Url::new()).for_field("website"),
                ])
            )
            .when(
                field("account_type").equals("personal"),
                All::new(vec![
                    Required::new().for_field("first_name"),
                    Required::new().for_field("last_name"),
                    Optional::new(Date::new()).for_field("birth_date"),
                ])
            )
            .otherwise(
                Fail::new("Invalid account type")
            )
    )
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞ —Å—Ç—Ä–∞–Ω–∞
    .rule("address_validation",
        When::new(
            field("country").exists(),
            AddressValidator::for_country(field("country"))
        )
    )
    
    // XOR: –ª–∏–±–æ email –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω, –ª–∏–±–æ —É–∫–∞–∑–∞–Ω —Ç–µ–ª–µ—Ñ–æ–Ω
    .rule("contact_verification",
        Xor::new()
            .add(field("email_verified").equals(true))
            .add(field("phone").exists().and(PhoneNumber::valid()))
            .expect(XorExpectation::ExactlyOne)
    )
    
    // –ó–∞–≤–∏—Å–∏–º—ã–µ –ø—Ä–∞–≤–∏–ª–∞
    .dependent_rule("premium_features",
        When::new(
            field("subscription").equals("premium"),
            All::new(vec![
                Required::new().for_field("payment_method"),
                Required::new().for_field("billing_address"),
            ])
        ),
        vec!["account_type_validation".to_string()]
    );

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
let form_data = json!({
    "username": "john_doe",
    "email": "john@example.com",
    "password": "SecurePass123!",
    "account_type": "business",
    "company_name": "Acme Corp",
    "tax_id": "12-3456789",
    "country": "US",
    "subscription": "premium",
    "payment_method": "card",
    "billing_address": {...}
});

let result = registration_validator.validate(&form_data).await?;
```

### –ü—Ä–∏–º–µ—Ä 2: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Å –≤–µ—Å–∞–º–∏

```rust
// –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö —Å –≤–µ—Å–∞–º–∏
let quality_validator = WeightedOr::new()
    .add(field("source").equals("verified"), 1.0)
    .add(field("confidence").greater_than(0.8), 0.8)
    .add(field("reviews_count").greater_than(10), 0.5)
    .add(field("last_updated").recent(Duration::days(30)), 0.3)
    .min_weight(1.5); // –ù—É–∂–Ω–æ –Ω–∞–±—Ä–∞—Ç—å –º–∏–Ω–∏–º—É–º 1.5 –±–∞–ª–ª–∞

// –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –ø–æ–ª–µ–π
let parallel_validator = ParallelAnd::new()
    .add(EmailValidator::new().for_field("email"))
    .add(UrlValidator::new().for_field("website"))
    .add(PhoneValidator::new().for_field("phone"))
    .add(AddressValidator::new().for_field("address"))
    .max_concurrency(4)
    .fail_fast();
```

### –ü—Ä–∏–º–µ—Ä 3: –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è

```rust
// –í–∞–ª–∏–¥–∞—Ü–∏—è —Å —É—á–µ—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
let context_validator = When::new(
    ContextCondition::new(|ctx| ctx.user_role == "admin"),
    PermissiveValidator::new()
).otherwise(
    StrictValidator::new()
);

// –í–∞–ª–∏–¥–∞—Ü–∏—è —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
let dynamic_validator = DynamicRuleValidator::new()
    .load_rules_from_db(&db_connection)
    .await?
    .with_cache(Duration::minutes(5));
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–≠—Ç–∏ —É–ª—É—á—à–µ–Ω–∏—è –¥–µ–ª–∞—é—Ç —Å–∏—Å—Ç–µ–º—É —É—Å–ª–æ–≤–Ω—ã—Ö –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤:
- **–ë–æ–ª–µ–µ –≥–∏–±–∫–æ–π** - –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–ª–æ–∂–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π –∏ –∫–æ–º–ø–æ–∑–∏—Ü–∏–π
- **–ë–æ–ª–µ–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–π** - –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
- **–ë–æ–ª–µ–µ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ–π** - –±–æ–≥–∞—Ç—ã–π DSL –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –ø—Ä–∞–≤–∏–ª
- **–ë–æ–ª–µ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ–π** - –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∞–≤–∏–ª –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

–°–∏—Å—Ç–µ–º–∞ —Ç–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏, —Å–æ—Ö—Ä–∞–Ω—è—è –ø—Ä–∏ —ç—Ç–æ–º —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç—å –∫–æ–¥–∞.
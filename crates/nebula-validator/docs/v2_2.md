# üî• Core —É–ª—É—á—à–µ–Ω–∏—è nebula-validator

## üìã –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ
1. [–£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ Valid/Invalid](#—É–ª—É—á—à–µ–Ω–Ω–∞—è-—Å–∏—Å—Ç–µ–º–∞-validinvalid)
2. [–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –±–∞–∑–æ–≤—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã](#–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-–±–∞–∑–æ–≤—ã–µ-–≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã)
3. [–°–∏—Å—Ç–µ–º–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π](#—Å–∏—Å—Ç–µ–º–∞-—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π)
4. [–£–ª—É—á—à–µ–Ω–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è](#—É–ª—É—á—à–µ–Ω–Ω–∞—è-–∫–æ–º–ø–æ–∑–∏—Ü–∏—è)
5. [–°–∏—Å—Ç–µ–º–∞ –ø—Ä–∞–≤–∏–ª –∏ constraints](#—Å–∏—Å—Ç–µ–º–∞-–ø—Ä–∞–≤–∏–ª-–∏-constraints)

## –£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ Valid/Invalid

### 1. **Core Valid/Invalid —Ç–∏–ø—ã —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å—é**

```rust
// nebula-validator/src/core/validity.rs

use std::fmt::{self, Display, Debug};
use serde::{Serialize, Deserialize};

/// –†–µ–∑—É–ª—å—Ç–∞—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ - –ª–∏–±–æ Valid, –ª–∏–±–æ Invalid
#[derive(Debug, Clone)]
pub enum Validated<T> {
    Valid(Valid<T>),
    Invalid(Invalid<T>),
}

impl<T> Validated<T> {
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –≤–∞–ª–∏–¥–Ω–æ –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ
    pub fn is_valid(&self) -> bool {
        matches!(self, Validated::Valid(_))
    }
    
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω–µ–≤–∞–ª–∏–¥–Ω–æ –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ
    pub fn is_invalid(&self) -> bool {
        matches!(self, Validated::Invalid(_))
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ None
    pub fn valid(self) -> Option<Valid<T>> {
        match self {
            Validated::Valid(v) => Some(v),
            Validated::Invalid(_) => None,
        }
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ None
    pub fn invalid(self) -> Option<Invalid<T>> {
        match self {
            Validated::Valid(_) => None,
            Validated::Invalid(i) => Some(i),
        }
    }
    
    /// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ Result
    pub fn into_result(self) -> Result<Valid<T>, Invalid<T>> {
        match self {
            Validated::Valid(v) => Ok(v),
            Validated::Invalid(i) => Err(i),
        }
    }
    
    /// Map over valid value
    pub fn map<U, F>(self, f: F) -> Validated<U>
    where
        F: FnOnce(T) -> U,
    {
        match self {
            Validated::Valid(v) => Validated::Valid(v.map(f)),
            Validated::Invalid(i) => Validated::Invalid(i.map_value(f)),
        }
    }
    
    /// FlatMap –¥–ª—è —Ü–µ–ø–æ—á–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–π
    pub async fn and_then<U, F, Fut>(self, f: F) -> Validated<U>
    where
        F: FnOnce(Valid<T>) -> Fut,
        Fut: std::future::Future<Output = Validated<U>>,
    {
        match self {
            Validated::Valid(v) => f(v).await,
            Validated::Invalid(i) => Validated::Invalid(Invalid {
                value: None, // –ú—ã –ø–æ—Ç–µ—Ä—è–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Ç–∏–ø–∞
                errors: i.errors,
                metadata: i.metadata,
            }),
        }
    }
    
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    pub async fn or_else<F, Fut>(self, f: F) -> Validated<T>
    where
        F: FnOnce(Invalid<T>) -> Fut,
        Fut: std::future::Future<Output = Validated<T>>,
    {
        match self {
            Validated::Valid(v) => Validated::Valid(v),
            Validated::Invalid(i) => f(i).await,
        }
    }
}

/// –í–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
#[derive(Debug, Clone)]
pub struct Valid<T> {
    value: T,
    proof: ValidationProof,
    transformations: Vec<TransformationRecord>,
}

impl<T> Valid<T> {
    /// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    pub(crate) fn new(value: T, proof: ValidationProof) -> Self {
        Self {
            value,
            proof,
            transformations: Vec::new(),
        }
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —Å—Å—ã–ª–∫–µ
    pub fn value(&self) -> &T {
        &self.value
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ–º
    pub fn into_value(self) -> T {
        self.value
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
    pub fn proof(&self) -> &ValidationProof {
        &self.proof
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
    pub fn transformations(&self) -> &[TransformationRecord] {
        &self.transformations
    }
    
    /// Map –∑–Ω–∞—á–µ–Ω–∏–µ —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
    pub fn map<U, F>(self, f: F) -> Valid<U>
    where
        F: FnOnce(T) -> U,
    {
        Valid {
            value: f(self.value),
            proof: self.proof,
            transformations: self.transformations,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
    pub fn with_transformation(mut self, record: TransformationRecord) -> Self {
        self.transformations.push(record);
        self
    }
    
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω–µ –∏—Å—Ç–µ–∫ –ª–∏ —Å—Ä–æ–∫ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
    pub fn is_expired(&self) -> bool {
        if let Some(expires_at) = self.proof.expires_at {
            Utc::now() > expires_at
        } else {
            false
        }
    }
    
    /// –û–±–Ω–æ–≤–∏—Ç—å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ
    pub fn refresh_proof(mut self, new_proof: ValidationProof) -> Self {
        self.proof = new_proof;
        self
    }
}

/// –ù–µ–≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å –æ—à–∏–±–∫–∞–º–∏
#[derive(Debug, Clone)]
pub struct Invalid<T> {
    value: Option<T>, // –ú–æ–∂–µ—Ç –±—ã—Ç—å None –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —Å–∫–æ–Ω—Å—Ç—Ä—É–∏—Ä–æ–≤–∞—Ç—å
    errors: Vec<ValidationError>,
    metadata: InvalidMetadata,
}

impl<T> Invalid<T> {
    /// –°–æ–∑–¥–∞—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    pub(crate) fn new(value: T, errors: Vec<ValidationError>) -> Self {
        Self {
            value: Some(value),
            errors,
            metadata: InvalidMetadata::default(),
        }
    }
    
    /// –°–æ–∑–¥–∞—Ç—å –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏—è (–∫–æ–≥–¥–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —Å–∫–æ–Ω—Å—Ç—Ä—É–∏—Ä–æ–≤–∞—Ç—å)
    pub(crate) fn without_value(errors: Vec<ValidationError>) -> Self {
        Self {
            value: None,
            errors,
            metadata: InvalidMetadata::default(),
        }
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å
    pub fn value(&self) -> Option<&T> {
        self.value.as_ref()
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ–º
    pub fn into_value(self) -> Option<T> {
        self.value
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –æ—à–∏–±–∫–∏
    pub fn errors(&self) -> &[ValidationError] {
        &self.errors
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    pub fn metadata(&self) -> &InvalidMetadata {
        &self.metadata
    }
    
    /// Map –∑–Ω–∞—á–µ–Ω–∏–µ –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
    pub fn map_value<U, F>(self, f: F) -> Invalid<U>
    where
        F: FnOnce(T) -> U,
    {
        Invalid {
            value: self.value.map(f),
            errors: self.errors,
            metadata: self.metadata,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É
    pub fn add_error(mut self, error: ValidationError) -> Self {
        self.errors.push(error);
        self
    }
    
    /// –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫–∏
    pub async fn try_fix<F, Fut>(self, fixer: F) -> Validated<T>
    where
        F: FnOnce(Option<T>, Vec<ValidationError>) -> Fut,
        Fut: std::future::Future<Output = Result<T, Vec<ValidationError>>>,
    {
        match fixer(self.value, self.errors).await {
            Ok(fixed) => Validated::Valid(Valid::new(
                fixed,
                ValidationProof::fixed(),
            )),
            Err(errors) => Validated::Invalid(Invalid::without_value(errors)),
        }
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–≤—É—é –æ—à–∏–±–∫—É
    pub fn first_error(&self) -> Option<&ValidationError> {
        self.errors.first()
    }
    
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∫–æ–¥ –æ—à–∏–±–∫–∏
    pub fn has_error_code(&self, code: &ErrorCode) -> bool {
        self.errors.iter().any(|e| &e.code == code)
    }
}

/// –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
#[derive(Debug, Clone, Default)]
pub struct InvalidMetadata {
    pub attempted_fixes: usize,
    pub validation_duration: Option<Duration>,
    pub validator_chain: Vec<ValidatorId>,
}

/// –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationProof {
    pub validator_id: ValidatorId,
    pub validated_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
    pub context: HashMap<String, Value>,
    pub signature: Option<String>,
    pub proof_type: ProofType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProofType {
    /// –û–±—ã—á–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
    Standard,
    /// –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    Fixed,
    /// –í–∞–ª–∏–¥–∞—Ü–∏—è —Å –ø–æ–¥–ø–∏—Å—å—é
    Signed(String),
    /// –°–æ—Å—Ç–∞–≤–Ω–æ–µ –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ
    Composite(Vec<ValidationProof>),
    /// –£—Å–ª–æ–≤–Ω–æ–µ –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ
    Conditional { condition: String, sub_proof: Box<ValidationProof> },
}

impl ValidationProof {
    /// –°–æ–∑–¥–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ
    pub fn new(validator_id: ValidatorId) -> Self {
        Self {
            validator_id,
            validated_at: Utc::now(),
            expires_at: None,
            context: HashMap::new(),
            signature: None,
            proof_type: ProofType::Standard,
        }
    }
    
    /// –°–æ–∑–¥–∞—Ç—å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ —Å TTL
    pub fn with_ttl(mut self, ttl: Duration) -> Self {
        self.expires_at = Some(Utc::now() + ttl);
        self
    }
    
    /// –°–æ–∑–¥–∞—Ç—å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    pub fn fixed() -> Self {
        Self {
            validator_id: ValidatorId::new("fixed"),
            validated_at: Utc::now(),
            expires_at: None,
            context: HashMap::new(),
            signature: None,
            proof_type: ProofType::Fixed,
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
    pub fn with_context(mut self, key: impl Into<String>, value: Value) -> Self {
        self.context.insert(key.into(), value);
        self
    }
}

/// –ó–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransformationRecord {
    pub transformer_id: String,
    pub applied_at: DateTime<Utc>,
    pub description: String,
    pub reversible: bool,
}
```

### 2. **–ë–∞–∑–æ–≤—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã Always/Never**

```rust
// nebula-validator/src/validators/basic.rs

/// –í–∞–ª–∏–¥–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ —É—Å–ø–µ—à–µ–Ω
#[derive(Debug, Clone)]
pub struct AlwaysValid {
    proof_ttl: Option<Duration>,
}

impl AlwaysValid {
    pub fn new() -> Self {
        Self { proof_ttl: None }
    }
    
    pub fn with_ttl(mut self, ttl: Duration) -> Self {
        self.proof_ttl = Some(ttl);
        self
    }
}

#[async_trait]
impl Validatable for AlwaysValid {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let mut proof = ValidationProof::new(ValidatorId::new("always_valid"));
        if let Some(ttl) = self.proof_ttl {
            proof = proof.with_ttl(ttl);
        }
        ValidationResult::success_with_proof((), proof)
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "always_valid",
            "Always returns valid",
            ValidatorCategory::Basic,
        )
    }
    
    fn complexity(&self) -> ValidationComplexity {
        ValidationComplexity::Trivial
    }
}

/// –í–∞–ª–∏–¥–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ –Ω–µ—É—Å–ø–µ—à–µ–Ω
#[derive(Debug, Clone)]
pub struct AlwaysInvalid {
    error: ValidationError,
}

impl AlwaysInvalid {
    pub fn new(message: impl Into<String>) -> Self {
        Self {
            error: ValidationError::new(
                ErrorCode::AlwaysInvalid,
                message,
            ),
        }
    }
    
    pub fn with_code(code: ErrorCode, message: impl Into<String>) -> Self {
        Self {
            error: ValidationError::new(code, message),
        }
    }
}

#[async_trait]
impl Validatable for AlwaysInvalid {
    async fn validate(&self, _value: &Value) -> ValidationResult<()> {
        ValidationResult::failure(vec![self.error.clone()])
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "always_invalid",
            "Always returns invalid",
            ValidatorCategory::Basic,
        )
    }
    
    fn complexity(&self) -> ValidationComplexity {
        ValidationComplexity::Trivial
    }
}

/// –í–∞–ª–∏–¥–∞—Ç–æ—Ä —Å –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º
#[derive(Clone)]
pub struct Predicate<F> {
    predicate: F,
    error_message: String,
    name: String,
}

impl<F> Predicate<F>
where
    F: Fn(&Value) -> bool + Send + Sync + Clone,
{
    pub fn new(name: impl Into<String>, predicate: F, error_message: impl Into<String>) -> Self {
        Self {
            predicate,
            error_message: error_message.into(),
            name: name.into(),
        }
    }
}

#[async_trait]
impl<F> Validatable for Predicate<F>
where
    F: Fn(&Value) -> bool + Send + Sync + Clone,
{
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        if (self.predicate)(value) {
            ValidationResult::success(())
        } else {
            ValidationResult::failure(vec![
                ValidationError::new(
                    ErrorCode::PredicateFailed,
                    &self.error_message,
                )
            ])
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            self.name.clone(),
            format!("Predicate validator: {}", self.name),
            ValidatorCategory::Basic,
        )
    }
}
```

## –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –±–∞–∑–æ–≤—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã

### 1. **Lazy –∏ Deferred –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã**

```rust
// nebula-validator/src/validators/lazy.rs

/// –õ–µ–Ω–∏–≤—ã–π –≤–∞–ª–∏–¥–∞—Ç–æ—Ä - —Å–æ–∑–¥–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
pub struct Lazy<F> {
    factory: F,
    cached: Arc<RwLock<Option<Box<dyn Validatable>>>>,
}

impl<F> Lazy<F>
where
    F: Fn() -> Box<dyn Validatable> + Send + Sync,
{
    pub fn new(factory: F) -> Self {
        Self {
            factory,
            cached: Arc::new(RwLock::new(None)),
        }
    }
}

#[async_trait]
impl<F> Validatable for Lazy<F>
where
    F: Fn() -> Box<dyn Validatable> + Send + Sync,
{
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let mut cache = self.cached.write().await;
        if cache.is_none() {
            *cache = Some((self.factory)());
        }
        
        cache.as_ref().unwrap().validate(value).await
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "lazy",
            "Lazy validator",
            ValidatorCategory::Advanced,
        )
    }
}

/// –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–π –≤–∞–ª–∏–¥–∞—Ç–æ—Ä - –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–æ–∑–∂–µ
pub struct Deferred {
    validator: Arc<RwLock<Option<Box<dyn Validatable>>>>,
}

impl Deferred {
    pub fn new() -> Self {
        Self {
            validator: Arc::new(RwLock::new(None)),
        }
    }
    
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub async fn set<V: Validatable + 'static>(&self, validator: V) {
        let mut lock = self.validator.write().await;
        *lock = Some(Box::new(validator));
    }
    
    /// –°–±—Ä–æ—Å–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    pub async fn reset(&self) {
        let mut lock = self.validator.write().await;
        *lock = None;
    }
}

#[async_trait]
impl Validatable for Deferred {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let lock = self.validator.read().await;
        match lock.as_ref() {
            Some(validator) => validator.validate(value).await,
            None => ValidationResult::success(()), // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —É—Å–ø–µ—Ö
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "deferred",
            "Deferred validator",
            ValidatorCategory::Advanced,
        )
    }
}
```

### 2. **Memoized –∏ Throttled –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã**

```rust
// nebula-validator/src/validators/performance.rs

/// –ú–µ–º–æ–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–∞–ª–∏–¥–∞—Ç–æ—Ä - –∫—ç—à–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
pub struct Memoized<V> {
    validator: V,
    cache: Arc<DashMap<u64, (ValidationResult<()>, Instant)>>,
    ttl: Duration,
    max_entries: usize,
}

impl<V: Validatable> Memoized<V> {
    pub fn new(validator: V, ttl: Duration) -> Self {
        Self {
            validator,
            cache: Arc::new(DashMap::new()),
            ttl,
            max_entries: 1000,
        }
    }
    
    pub fn with_max_entries(mut self, max: usize) -> Self {
        self.max_entries = max;
        self
    }
    
    fn calculate_hash(&self, value: &Value) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        
        let mut hasher = DefaultHasher::new();
        format!("{:?}", value).hash(&mut hasher);
        hasher.finish()
    }
}

#[async_trait]
impl<V: Validatable> Validatable for Memoized<V> {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        let hash = self.calculate_hash(value);
        
        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫—ç—à
        if let Some(entry) = self.cache.get(&hash) {
            let (ref result, ref timestamp) = *entry;
            if timestamp.elapsed() < self.ttl {
                return result.clone();
            }
        }
        
        // –í—ã–ø–æ–ª–Ω–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é
        let result = self.validator.validate(value).await;
        
        // –û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if self.cache.len() >= self.max_entries {
            let now = Instant::now();
            self.cache.retain(|_, (_, timestamp)| {
                now.duration_since(*timestamp) < self.ttl
            });
        }
        
        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –∫—ç—à
        self.cache.insert(hash, (result.clone(), Instant::now()));
        
        result
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        let base = self.validator.metadata();
        ValidatorMetadata::new(
            format!("memoized_{}", base.id.as_str()),
            format!("Memoized {}", base.name),
            ValidatorCategory::Performance,
        )
    }
}

/// Throttled –≤–∞–ª–∏–¥–∞—Ç–æ—Ä - –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —á–∞—Å—Ç–æ—Ç—É –≤—ã–∑–æ–≤–æ–≤
pub struct Throttled<V> {
    validator: V,
    rate_limiter: Arc<RateLimiter>,
}

pub struct RateLimiter {
    max_per_second: u32,
    window: Arc<RwLock<VecDeque<Instant>>>,
}

impl<V: Validatable> Throttled<V> {
    pub fn new(validator: V, max_per_second: u32) -> Self {
        Self {
            validator,
            rate_limiter: Arc::new(RateLimiter::new(max_per_second)),
        }
    }
}

#[async_trait]
impl<V: Validatable> Validatable for Throttled<V> {
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å rate limit
        if !self.rate_limiter.check_and_update().await {
            return ValidationResult::failure(vec![
                ValidationError::new(
                    ErrorCode::RateLimitExceeded,
                    "Validation rate limit exceeded",
                )
            ]);
        }
        
        self.validator.validate(value).await
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        let base = self.validator.metadata();
        ValidatorMetadata::new(
            format!("throttled_{}", base.id.as_str()),
            format!("Throttled {}", base.name),
            ValidatorCategory::Performance,
        )
    }
}
```

## –°–∏—Å—Ç–µ–º–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π

### 1. **Transformer trait –∏ –±–∞–∑–æ–≤—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏**

```rust
// nebula-validator/src/transform/mod.rs

/// Trait –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∑–Ω–∞—á–µ–Ω–∏–π
#[async_trait]
pub trait Transformer: Send + Sync {
    /// –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ
    async fn transform(&self, value: Value) -> Result<Value, TransformError>;
    
    /// –ü–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–∞
    fn metadata(&self) -> TransformerMetadata;
    
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –æ–±—Ä–∞—Ç–∏–º–∞ –ª–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è
    fn is_reversible(&self) -> bool {
        false
    }
    
    /// –û–±—Ä–∞—Ç–Ω–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è (–µ—Å–ª–∏ –æ–±—Ä–∞—Ç–∏–º–∞)
    async fn reverse(&self, value: Value) -> Result<Value, TransformError> {
        Err(TransformError::NotReversible)
    }
}

/// –í–∞–ª–∏–¥–∞—Ç–æ—Ä —Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
pub struct TransformingValidator<V, T> {
    validator: V,
    transformer: T,
    transform_before: bool,
}

impl<V, T> TransformingValidator<V, T> {
    pub fn before(validator: V, transformer: T) -> Self {
        Self {
            validator,
            transformer,
            transform_before: true,
        }
    }
    
    pub fn after(validator: V, transformer: T) -> Self {
        Self {
            validator,
            transformer,
            transform_before: false,
        }
    }
}

#[async_trait]
impl<V, T> Validatable for TransformingValidator<V, T>
where
    V: Validatable,
    T: Transformer,
{
    async fn validate(&self, value: &Value) -> ValidationResult<()> {
        if self.transform_before {
            // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å, –∑–∞—Ç–µ–º –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å
            let transformed = self.transformer.transform(value.clone()).await
                .map_err(|e| ValidationError::new(
                    ErrorCode::TransformationFailed,
                    e.to_string(),
                ))?;
            self.validator.validate(&transformed).await
        } else {
            // –í–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å, –∑–∞—Ç–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å
            self.validator.validate(value).await?;
            self.transformer.transform(value.clone()).await
                .map_err(|e| ValidationError::new(
                    ErrorCode::TransformationFailed,
                    e.to_string(),
                ))?;
            ValidationResult::success(())
        }
    }
    
    fn metadata(&self) -> ValidatorMetadata {
        ValidatorMetadata::new(
            "transforming_validator",
            "Validator with transformation",
            ValidatorCategory::Transform,
        )
    }
}

/// –¶–µ–ø–æ—á–∫–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
pub struct TransformChain {
    transformers: Vec<Box<dyn Transformer>>,
}

impl TransformChain {
    pub fn new() -> Self {
        Self {
            transformers: Vec::new(),
        }
    }
    
    pub fn add<T: Transformer + 'static>(mut self, transformer: T) -> Self {
        self.transformers.push(Box::new(transformer));
        self
    }
}

#[async_trait]
impl Transformer for TransformChain {
    async fn transform(&self, mut value: Value) -> Result<Value, TransformError> {
        for transformer in &self.transformers {
            value = transformer.transform(value).await?;
        }
        Ok(value)
    }
    
    fn metadata(&self) -> TransformerMetadata {
        TransformerMetadata::new(
            "transform_chain",
            format!("Chain of {} transformers", self.transformers.len()),
        )
    }
    
    fn is_reversible(&self) -> bool {
        self.transformers.iter().all(|t| t.is_reversible())
    }
    
    async fn reverse(&self, mut value: Value) -> Result<Value, TransformError> {
        // –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        for transformer in self.transformers.iter().rev() {
            value = transformer.reverse(value).await?;
        }
        Ok(value)
    }
}
```

### 2. **–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä—ã**

```rust
// nebula-validator/src/transform/implementations.rs

/// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–æ–∫
pub struct StringNormalizer {
    trim: bool,
    lowercase: bool,
    uppercase: bool,
    remove_whitespace: bool,
    max_consecutive_spaces: Option<usize>,
}

impl StringNormalizer {
    pub fn standard() -> Self {
        Self {
            trim: true,
            lowercase: false,
            uppercase: false,
            remove_whitespace: false,
            max_consecutive_spaces: Some(1),
        }
    }
    
    pub fn aggressive() -> Self {
        Self {
            trim: true,
            lowercase: true,
            uppercase: false,
            remove_whitespace: false,
            max_consecutive_spaces: Some(1),
        }
    }
}

#[async_trait]
impl Transformer for StringNormalizer {
    async fn transform(&self, value: Value) -> Result<Value, TransformError> {
        if let Value::String(mut s) = value {
            if self.trim {
                s = s.trim().to_string();
            }
            if self.lowercase {
                s = s.to_lowercase();
            }
            if self.uppercase {
                s = s.to_uppercase();
            }
            if self.remove_whitespace {
                s = s.chars().filter(|c| !c.is_whitespace()).collect();
            }
            if let Some(max) = self.max_consecutive_spaces {
                let re = regex::Regex::new(&format!(r"\s{{{},}}", max + 1)).unwrap();
                s = re.replace_all(&s, " ".repeat(max)).to_string();
            }
            Ok(Value::String(s))
        } else {
            Ok(value)
        }
    }
    
    fn metadata(&self) -> TransformerMetadata {
        TransformerMetadata::new(
            "string_normalizer",
            "Normalizes string values",
        )
    }
}

/// –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ —á–∏—Å–µ–ª
pub struct NumberRounder {
    precision: u32,
    mode: RoundingMode,
}

#[derive(Debug, Clone)]
pub enum RoundingMode {
    Round,
    Floor,
    Ceil,
    Truncate,
}

#[async_trait]
impl Transformer for NumberRounder {
    async fn transform(&self, value: Value) -> Result<Value, TransformError> {
        if let Value::Number(n) = value {
            if let Some(f) = n.as_f64() {
                let multiplier = 10_f64.powi(self.precision as i32);
                let rounded = match self.mode {
                    RoundingMode::Round => (f * multiplier).round() / multiplier,
                    RoundingMode::Floor => (f * multiplier).floor() / multiplier,
                    RoundingMode::Ceil => (f * multiplier).ceil() / multiplier,
                    RoundingMode::Truncate => (f * multiplier).trunc() / multiplier,
                };
                Ok(json!(rounded))
            } else {
                Ok(value)
            }
        } else {
            Ok(value)
        }
    }
    
    fn metadata(&self) -> TransformerMetadata {
        TransformerMetadata::new(
            "number_rounder",
            format!("Rounds numbers to {} decimal places", self.precision),
        )
    }
}

/// –ú–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
pub struct DataMasker {
    fields_to_mask: Vec<String>,
    mask_pattern: String,
    preserve_length: bool,
}

impl DataMasker {
    pub fn new(fields: Vec<String>) -> Self {
        Self {
            fields_to_mask: fields,
            mask_pattern: "***".to_string(),
            preserve_length: false,
        }
    }
    
    pub fn credit_card() -> Self {
        Self {
            fields_to_mask: vec!["card_number".to_string()],
            mask_pattern: "*".to_string(),
            preserve_length: true,
        }
    }
}

#[async_trait]
impl Transformer for DataMasker {
    async fn transform(&self, value: Value) -> Result<Value, TransformError> {
        if let Value::Object(mut map) = value {
            for field in &self.fields_to_mask {
                if let Some(Value::String(s)) = map.get_mut(field) {
                    if self.preserve_length {
                        let len = s.len();
                        if len > 4 {
                            let visible = &s[len-4..];
                            *s = format!("{}{}", self.mask_pattern.repeat(len-4), visible);
                        } else {
                            *s = self.mask_pattern.repeat(len);
                        }
                    } else {
                        *s = self.mask_pattern.clone();
                    }
                }
            }
            Ok(Value::Object(map))
        } else {
            Ok(value)
        }
    }
    
    fn metadata(&self) -> TransformerMetadata {
        TransformerMetadata::new(
            "data_masker",
            "Masks sensitive data fields",
        )
    }
}
```

## –£–ª—É—á—à–µ–Ω–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è

### 1. **Pipeline –≤–∞–ª–∏–¥–∞—Ü–∏–∏**

```rust
// nebula-validator/src/pipeline/mod.rs

/// Pipeline –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏
pub struct ValidationPipeline {
    stages: Vec<PipelineStage>,
    error_handler: ErrorHandler,
    metrics: Arc<Mutex<PipelineMetrics>>,
}

pub struct PipelineStage {
    name: String,
    validator: Box<dyn Validatable>,
    transformer: Option<Box<dyn Transformer>>,
    condition: Option<Box<dyn Condition>>,
    on_error: StageErrorAction,
}

#[derive(Debug, Clone)]
pub enum StageErrorAction {
    /// –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å pipeline
    Stop,
    /// –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–æ —Å–ª–µ–¥—É—é—â–∏–º —ç—Ç–∞–ø–æ–º
    Continue,
    /// –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å N —Å–ª–µ–¥—É—é—â–∏—Ö —ç—Ç–∞–ø–æ–≤
    Skip(usize),
    /// –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É —ç—Ç–∞–ø—É
    Goto(String),
    /// –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    Fallback(Box<dyn Validatable>),
}

impl ValidationPipeline {
    pub fn builder() -> PipelineBuilder {
        PipelineBuilder::new()
    }
    
    pub async fn execute(&self, value: Value) -> PipelineResult {
        let start = Instant::now();
        let mut current_value = value;
        let mut stage_results = Vec::new();
        let mut skip_count = 0;
        
        for (index, stage) in self.stages.iter().enumerate() {
            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å
            if skip_count > 0 {
                skip_count -= 1;
                continue;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —É—Å–ª–æ–≤–∏–µ
            if let Some(ref condition) = stage.condition {
                let ctx = ValidationContext::new();
                if !condition.evaluate(&current_value, &ctx).await {
                    stage_results.push(StageResult::skipped(&stage.name));
                    continue;
                }
            }
            
            // –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é
            if let Some(ref transformer) = stage.transformer {
                match transformer.transform(current_value.clone()).await {
                    Ok(transformed) => current_value = transformed,
                    Err(e) => {
                        stage_results.push(StageResult::transform_error(&stage.name, e));
                        if matches!(stage.on_error, StageErrorAction::Stop) {
                            break;
                        }
                    }
                }
            }
            
            // –í—ã–ø–æ–ª–Ω–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é
            let validation_start = Instant::now();
            match stage.validator.validate(&current_value).await {
                Ok(_) => {
                    stage_results.push(StageResult::success(
                        &stage.name,
                        validation_start.elapsed(),
                    ));
                },
                Err(e) => {
                    stage_results.push(StageResult::failure(&stage.name, e.clone()));
                    
                    match &stage.on_error {
                        StageErrorAction::Stop => break,
                        StageErrorAction::Continue => continue,
                        StageErrorAction::Skip(n) => skip_count = *n,
                        StageErrorAction::Goto(target) => {
                            // –ù–∞–π—Ç–∏ —Ü–µ–ª–µ–≤–æ–π —ç—Ç–∞–ø
                            if let Some(target_index) = self.stages.iter()
                                .position(|s| s.name == *target) {
                                skip_count = target_index.saturating_sub(index + 1);
                            }
                        },
                        StageErrorAction::Fallback(fallback) => {
                            // –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
                            if fallback.validate(&current_value).await.is_ok() {
                                stage_results.last_mut().unwrap().mark_recovered();
                            }
                        },
                    }
                }
            }
        }
        
        // –ó–∞–ø–∏—Å–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏
        self.metrics.lock().unwrap().record_execution(
            start.elapsed(),
            &stage_results,
        );
        
        PipelineResult {
            final_value: current_value,
            stage_results,
            total_duration: start.elapsed(),
        }
    }
}

pub struct PipelineBuilder {
    stages: Vec<PipelineStage>,
    error_handler: ErrorHandler,
}

impl PipelineBuilder {
    pub fn new() -> Self {
        Self {
            stages: Vec::new(),
            error_handler: ErrorHandler::default(),
        }
    }
    
    pub fn stage<V: Validatable + 'static>(
        mut self,
        name: impl Into<String>,
        validator: V,
    ) -> Self {
        self.stages.push(PipelineStage {
            name: name.into(),
            validator: Box::new(validator),
            transformer: None,
            condition: None,
            on_error: StageErrorAction::Stop,
        });
        self
    }
    
    pub fn conditional_stage<V, C>(
        mut self,
        name: impl Into<String>,
        condition: C,
        validator: V,
    ) -> Self
    where
        V: Validatable + 'static,
        C: Condition + 'static,
    {
        self.stages.push(PipelineStage {
            name: name.into(),
            validator: Box::new(validator),
            transformer: None,
            condition: Some(Box::new(condition)),
            on_error: StageErrorAction::Stop,
        });
        self
    }
    
    pub fn transform_stage<T: Transformer + 'static>(
        mut self,
        name: impl Into<String>,
        transformer: T,
    ) -> Self {
        self.stages.push(PipelineStage {
            name: name.into(),
            validator: Box::new(AlwaysValid::new()),
            transformer: Some(Box::new(transformer)),
            condition: None,
            on_error: StageErrorAction::Continue,
        });
        self
    }
    
    pub fn build(self) -> ValidationPipeline {
        ValidationPipeline {
            stages: self.stages,
            error_handler: self.error_handler,
            metrics: Arc::new(Mutex::new(PipelineMetrics::new())),
        }
    }
}
```

## –°–∏—Å—Ç–µ–º–∞ –ø—Ä–∞–≤–∏–ª –∏ constraints

### 1. **Rule-based –≤–∞–ª–∏–¥–∞—Ü–∏—è**

```rust
// nebula-validator/src/rules/mod.rs

/// –ü—Ä–∞–≤–∏–ª–æ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
pub trait Rule: Send + Sync {
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø—Ä–∞–≤–∏–ª–æ
    async fn apply(&self, value: &Value, context: &RuleContext) -> RuleResult;
    
    /// –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø—Ä–∞–≤–∏–ª–∞
    fn priority(&self) -> i32 {
        0
    }
    
    /// –ü–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
    fn metadata(&self) -> RuleMetadata;
}

/// –î–≤–∏–∂–æ–∫ –ø—Ä–∞–≤–∏–ª
pub struct RuleEngine {
    rules: Arc<RwLock<Vec<Box<dyn Rule>>>>,
    context: Arc<RwLock<RuleContext>>,
    executor: RuleExecutor,
}

impl RuleEngine {
    pub fn new() -> Self {
        Self {
            rules: Arc::new(RwLock::new(Vec::new())),
            context: Arc::new(RwLock::new(RuleContext::new())),
            executor: RuleExecutor::new(),
        }
    }
    
    /// –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–∞–≤–∏–ª–æ
    pub async fn add_rule<R: Rule + 'static>(&self, rule: R) {
        let mut rules = self.rules.write().await;
        rules.push(Box::new(rule));
        rules.sort_by_key(|r| -r.priority());
    }
    
    /// –í—ã–ø–æ–ª–Ω–∏—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∏–ª–∞
    pub async fn execute(&self, value: &Value) -> EngineResult {
        let rules = self.rules.read().await;
        let context = self.context.read().await;
        
        self.executor.execute_rules(&rules, value, &context).await
    }
    
    /// –í—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–∞–≤–∏–ª–∞ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —Ç–µ–≥–æ–º
    pub async fn execute_tagged(&self, value: &Value, tag: &str) -> EngineResult {
        let rules = self.rules.read().await;
        let context = self.context.read().await;
        
        let filtered: Vec<_> = rules.iter()
            .filter(|r| r.metadata().tags.contains(&tag.to_string()))
            .map(|r| r.as_ref())
            .collect();
        
        self.executor.execute_rules(&filtered, value, &context).await
    }
}

/// Constraint - —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Ç–∏–ø –ø—Ä–∞–≤–∏–ª–∞
pub struct Constraint {
    name: String,
    predicate: Box<dyn Fn(&Value) -> bool + Send + Sync>,
    error_message: String,
    severity: ConstraintSeverity,
}

#[derive(Debug, Clone)]
pub enum ConstraintSeverity {
    Error,    // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞
    Warning,  // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
    Info,     // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
}

impl Constraint {
    pub fn new(
        name: impl Into<String>,
        predicate: impl Fn(&Value) -> bool + Send + Sync + 'static,
        error_message: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            predicate: Box::new(predicate),
            error_message: error_message.into(),
            severity: ConstraintSeverity::Error,
        }
    }
    
    pub fn with_severity(mut self, severity: ConstraintSeverity) -> Self {
        self.severity = severity;
        self
    }
}

#[async_trait]
impl Rule for Constraint {
    async fn apply(&self, value: &Value, _context: &RuleContext) -> RuleResult {
        if (self.predicate)(value) {
            RuleResult::Pass
        } else {
            match self.severity {
                ConstraintSeverity::Error => RuleResult::Fail(self.error_message.clone()),
                ConstraintSeverity::Warning => RuleResult::Warn(self.error_message.clone()),
                ConstraintSeverity::Info => RuleResult::Info(self.error_message.clone()),
            }
        }
    }
    
    fn metadata(&self) -> RuleMetadata {
        RuleMetadata {
            name: self.name.clone(),
            tags: vec!["constraint".to_string()],
            description: Some(self.error_message.clone()),
        }
    }
}
```

## –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

### –ü—Ä–∏–º–µ—Ä 1: Valid/Invalid —Å–∏—Å—Ç–µ–º–∞

```rust
use nebula_validator::prelude::*;

// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
let validator = Predicate::new(
    "positive_number",
    |v| v.as_f64().map_or(false, |n| n > 0.0),
    "Number must be positive"
);

// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
let result = validator.validate(&json!(42.0)).await;

match result.into_validated() {
    Validated::Valid(valid) => {
        println!("Value is valid: {:?}", valid.value());
        println!("Proof: {:?}", valid.proof());
    },
    Validated::Invalid(invalid) => {
        println!("Value is invalid: {:?}", invalid.errors());
        
        // –ü–æ–ø—ã—Ç–∫–∞ –∏—Å–ø—Ä–∞–≤–∏—Ç—å
        let fixed = invalid.try_fix(|value, _errors| async {
            // –õ–æ–≥–∏–∫–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            Ok(json!(0.0))
        }).await;
    }
}
```

### –ü—Ä–∏–º–µ—Ä 2: Pipeline —Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è–º–∏

```rust
let pipeline = ValidationPipeline::builder()
    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    .transform_stage("normalize", StringNormalizer::standard())
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è email
    .stage("email", Email::new())
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å —Å fallback
    .stage("unique", UniqueValidator::new())
        .on_error(StageErrorAction::Fallback(
            Box::new(AlwaysValid::new())
        ))
    
    // –£—Å–ª–æ–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ premium —Ñ—É–Ω–∫—Ü–∏–π
    .conditional_stage(
        "premium",
        field("plan").equals("premium"),
        PremiumValidator::new()
    )
    
    .build();

let result = pipeline.execute(json!({
    "email": "  USER@EXAMPLE.COM  ",
    "plan": "premium"
})).await;

println!("Pipeline completed in {:?}", result.total_duration);
for stage in result.stage_results {
    println!("Stage {}: {:?}", stage.name, stage.status);
}
```

### –ü—Ä–∏–º–µ—Ä 3: Rule Engine

```rust
let engine = RuleEngine::new();

// –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∏–ª–∞
engine.add_rule(
    Constraint::new(
        "age_limit",
        |v| v["age"].as_u64().map_or(false, |a| a >= 18),
        "Must be 18 or older"
    ).with_severity(ConstraintSeverity::Error)
).await;

engine.add_rule(
    Constraint::new(
        "email_domain",
        |v| v["email"].as_str()
            .map_or(false, |e| !e.ends_with("@temp.com")),
        "Temporary email addresses not allowed"
    ).with_severity(ConstraintSeverity::Warning)
).await;

// –í—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–∞–≤–∏–ª–∞
let result = engine.execute(&json!({
    "age": 25,
    "email": "user@example.com"
})).await;
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–≠—Ç–∏ core —É–ª—É—á—à–µ–Ω–∏—è –¥–µ–ª–∞—é—Ç nebula-validator:
- **–ë–æ–ª–µ–µ –º–æ—â–Ω—ã–º** - Valid/Invalid —Å–∏—Å—Ç–µ–º–∞ —Å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞–º–∏
- **–ë–æ–ª–µ–µ –≥–∏–±–∫–∏–º** - –±–æ–≥–∞—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π –∏ –ø—Ä–∞–≤–∏–ª
- **–ë–æ–ª–µ–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–º** - –º–µ–º–æ–∏–∑–∞—Ü–∏—è, throttling, lazy loading
- **–ë–æ–ª–µ–µ –∫–æ–º–ø–æ–∑–∏—Ä—É–µ–º—ã–º** - pipelines, rule engines, chains
- **–ë–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–º** - error recovery, fallbacks, retries

–¢–µ–ø–µ—Ä—å –¥—Ä—É–≥–∏–µ –∫—Ä–µ–π—Ç—ã (nebula-value, nebula-parameter) –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –º–æ—â–Ω—É—é —Å–∏—Å—Ç–µ–º—É –≤–∞–ª–∏–¥–∞—Ü–∏–∏!
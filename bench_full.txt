warning: unreachable expression
  --> crates\nebula-value\src\core\path.rs:76:13
   |
76 |                current = match (current, segment) {
   |  ______________^         -
   | | _______________________|
77 | ||                 // Type mismatch errors
78 | ||                 (val, PathSegment::Key(key)) => {
79 | ||                     return Err(
...  ||
94 | ||             };
   | ||             ^
   | ||_____________|
   |  |_____________unreachable expression
   |                any code following this `match` expression is unreachable, as all arms diverge
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: use of deprecated associated function `chrono::NaiveDateTime::from_timestamp_opt`: use `DateTime::from_timestamp` instead
   --> crates\nebula-value\src\temporal\datetime.rs:147:24
    |
147 |         NaiveDateTime::from_timestamp_opt(seconds, nano_part)
    |                        ^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: use of deprecated method `chrono::NaiveDateTime::timestamp`: use `.and_utc().timestamp()` instead
   --> crates\nebula-value\src\temporal\datetime.rs:341:51
    |
341 |             .get_or_init(|| self.inner.to_naive().timestamp())
    |                                                   ^^^^^^^^^

warning: `nebula-value` (lib) generated 3 warnings
warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\batch.rs:249:44
    |
249 |     pub fn iter(&self) -> core::slice::Iter<T> {
    |                           -----------------^-- expected lifetime parameter
    |
note: the lint level is defined here
   --> crates\nebula-memory\src\lib.rs:53:9
    |
 53 | #![warn(rust_2018_idioms)]
    |         ^^^^^^^^^^^^^^^^
    = note: `#[warn(elided_lifetimes_in_paths)]` implied by `#[warn(rust_2018_idioms)]`
help: indicate the anonymous lifetime
    |
249 |     pub fn iter(&self) -> core::slice::Iter<'_, T> {
    |                                             +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\batch.rs:254:55
    |
254 |     pub fn iter_mut(&mut self) -> core::slice::IterMut<T> {
    |                                   --------------------^-- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
254 |     pub fn iter_mut(&mut self) -> core::slice::IterMut<'_, T> {
    |                                                        +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\lockfree.rs:159:58
    |
159 |     pub fn get(&self) -> MemoryResult<LockFreePooledValue<T>> {
    |                                       -------------------^-- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
159 |     pub fn get(&self) -> MemoryResult<LockFreePooledValue<'_, T>> {
    |                                                           +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\lockfree.rs:206:56
    |
206 |     pub fn try_get(&self) -> Option<LockFreePooledValue<T>> {
    |                                     -------------------^-- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
206 |     pub fn try_get(&self) -> Option<LockFreePooledValue<'_, T>> {
    |                                                         +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\thread_safe.rs:118:60
    |
118 |     pub fn get(&self) -> MemoryResult<ThreadSafePooledValue<T>> {
    |                                       ---------------------^-- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
118 |     pub fn get(&self) -> MemoryResult<ThreadSafePooledValue<'_, T>> {
    |                                                             +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\thread_safe.rs:123:58
    |
123 |     pub fn try_get(&self) -> Option<ThreadSafePooledValue<T>> {
    |                                     ---------------------^-- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
123 |     pub fn try_get(&self) -> Option<ThreadSafePooledValue<'_, T>> {
    |                                                           +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\pool\thread_safe.rs:154:95
    |
154 |     pub fn get_timeout(&self, timeout: Option<Duration>) -> MemoryResult<ThreadSafePooledValue<T>> {
    |                                                                          ---------------------^-- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
154 |     pub fn get_timeout(&self, timeout: Option<Duration>) -> MemoryResult<ThreadSafePooledValue<'_, T>> {
    |                                                                                                +++

warning: unused import: `hash::Hash`
  --> crates\nebula-memory\src\cache\policies\fifo.rs:15:5
   |
15 |     hash::Hash,
   |     ^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `hash::Hash`
  --> crates\nebula-memory\src\cache\policies\random.rs:14:33
   |
14 | use std::{collections::HashSet, hash::Hash, marker::PhantomData};
   |                                 ^^^^^^^^^^

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:160:53
    |
160 |     fn select_victim(&self, entries: &[EvictionEntry<K, V>]) -> Option<K>;
    |                                        -------------^----- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
160 |     fn select_victim(&self, entries: &[EvictionEntry<'_, K, V>]) -> Option<K>;
    |                                                      +++

warning: hidden lifetime parameters in types are deprecated
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:414:54
    |
414 |     fn select_victim(&self, _entries: &[EvictionEntry<K, V>]) -> Option<K> {
    |                                         -------------^----- expected lifetime parameter
    |
help: indicate the anonymous lifetime
    |
414 |     fn select_victim(&self, _entries: &[EvictionEntry<'_, K, V>]) -> Option<K> {
    |                                                       +++

warning: hidden lifetime parameters in types are deprecated
  --> crates\nebula-memory\src\cache\policies\mod.rs:71:35
   |
71 |     let entries: Vec<EvictionEntry<K, V>> = entries.collect();
   |                      -------------^----- expected lifetime parameter
   |
help: indicate the anonymous lifetime
   |
71 |     let entries: Vec<EvictionEntry<'_, K, V>> = entries.collect();
   |                                    +++

warning: unused import: `Hash`
   --> crates\nebula-memory\src\cache\policies\lfu.rs:574:26
    |
574 |         use core::hash::{Hash as _, Hasher};
    |                          ^^^^

warning: unused import: `hash::Hash`
  --> crates\nebula-memory\src\cache\policies\lfu.rs:15:5
   |
15 |     hash::Hash,
   |     ^^^^^^^^^^

warning: unused import: `Hash`
  --> crates\nebula-memory\src\cache\partitioned.rs:13:12
   |
13 |     hash::{Hash, Hasher},
   |            ^^^^

warning: unused import: `ArenaAllocate`
 --> crates\nebula-memory\src\arena\local.rs:8:20
  |
8 | use super::{Arena, ArenaAllocate, ArenaConfig};
  |                    ^^^^^^^^^^^^^

warning: unused import: `ArenaAllocate`
 --> crates\nebula-memory\src\arena\cross_thread.rs:7:20
  |
7 | use super::{Arena, ArenaAllocate, ArenaConfig, ArenaStats};
  |                    ^^^^^^^^^^^^^

warning: unused variable: `interval`
   --> crates\nebula-memory\src\cache\multi_level.rs:460:21
    |
460 |         if let Some(interval) = self.config.cleanup_interval {
    |                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_interval`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `levels_clone`
   --> crates\nebula-memory\src\cache\multi_level.rs:461:17
    |
461 |             let levels_clone = self
    |                 ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_levels_clone`

warning: unused variable: `start_time`
   --> crates\nebula-memory\src\cache\partitioned.rs:380:13
    |
380 |         let start_time = Instant::now();
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_start_time`

warning: unused variable: `max_partition`
   --> crates\nebula-memory\src\cache\partitioned.rs:672:22
    |
672 |         if let (Some(max_partition), Some(min_partition)) = (most_loaded, least_loaded) {
    |                      ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_partition`

warning: unused variable: `min_partition`
   --> crates\nebula-memory\src\cache\partitioned.rs:672:43
    |
672 |         if let (Some(max_partition), Some(min_partition)) = (most_loaded, least_loaded) {
    |                                           ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_partition`

warning: unused variable: `task_entry`
   --> crates\nebula-memory\src\cache\scheduled.rs:402:37
    |
402 |                         if let Some(task_entry) = tasks_guard
    |                                     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_task_entry`

warning: unused variable: `default_timeout`
   --> crates\nebula-memory\src\cache\scheduled.rs:432:13
    |
432 |         let default_timeout = self.scheduler_config.default_timeout;
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_default_timeout`

warning: unused variable: `context`
   --> crates\nebula-memory\src\cache\scheduled.rs:456:36
    |
456 |                 if let Some((task, context)) = task_and_context {
    |                                    ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_context`

warning: unused variable: `cache_for_task`
   --> crates\nebula-memory\src\cache\scheduled.rs:460:25
    |
460 |                     let cache_for_task = DummyScheduledCache {
    |                         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cache_for_task`

warning: unused variable: `timeout`
   --> crates\nebula-memory\src\cache\scheduled.rs:585:17
    |
585 |             let timeout = self.scheduler_config.shutdown_timeout;
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_timeout`

warning: unused variable: `cache`
   --> crates\nebula-memory\src\cache\scheduled.rs:823:19
    |
823 |     fn run(&self, cache: &ScheduledCache<K, V>, context: &TaskContext) -> TaskResult {
    |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_cache`

warning: unused variable: `entry`
   --> crates\nebula-memory\src\cache\policies\arc.rs:385:49
    |
385 |     pub fn record_insertion(&mut self, key: &K, entry: &CacheEntry<V>, size_hint: Option<usize>) {
    |                                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`

warning: unused variable: `entry`
   --> crates\nebula-memory\src\cache\policies\lfu.rs:284:49
    |
284 |     pub fn record_insertion(&mut self, key: &K, entry: &CacheEntry<V>, size_hint: Option<usize>) {
    |                                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`

warning: unused variable: `frequency`
   --> crates\nebula-memory\src\cache\policies\lfu.rs:625:39
    |
625 |     fn update_bucket_links(&mut self, frequency: u64) {
    |                                       ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_frequency`

warning: unused variable: `key_positions`
   --> crates\nebula-memory\src\cache\policies\lru.rs:605:17
    |
605 |                 key_positions,
    |                 ^^^^^^^^^^^^^ help: try ignoring the field: `key_positions: _`

warning: unused variable: `entry`
   --> crates\nebula-memory\src\cache\policies\lru.rs:586:49
    |
586 |     pub fn record_insertion(&mut self, key: &K, entry: &CacheEntry<V>, size_hint: Option<usize>) {
    |                                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`

warning: unused variable: `size`
   --> crates\nebula-memory\src\syscalls\direct.rs:182:36
    |
182 | pub fn memory_unmap(addr: *mut u8, size: usize) -> io::Result<()> {
    |                                    ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: unused variable: `sync_type`
   --> crates\nebula-memory\src\syscalls\direct.rs:357:48
    |
357 | pub fn memory_sync(addr: *mut u8, size: usize, sync_type: MemorySyncType) -> io::Result<()> {
    |                                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sync_type`

warning: trait `AllocResultExt` is never used
   --> crates\nebula-memory\src\allocator\error.rs:647:11
    |
647 | pub trait AllocResultExt<T> {
    |           ^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: trait `TrackExt` is never used
   --> crates\nebula-memory\src\allocator\tracked.rs:292:11
    |
292 | pub trait TrackExt: Sized {
    |           ^^^^^^^^

warning: field `memory_ops` is never read
  --> crates\nebula-memory\src\allocator\bump\mod.rs:38:5
   |
34 | pub struct BumpAllocator {
   |            ------------- field in this struct
...
38 |     memory_ops: MemoryOps,
   |     ^^^^^^^^^^

warning: field `memory` is never read
  --> crates\nebula-memory\src\allocator\pool\allocator.rs:30:5
   |
28 | pub struct PoolAllocator {
   |            ------------- field in this struct
29 |     /// Owned memory buffer containing all blocks
30 |     memory: Box<[u8]>,
   |     ^^^^^^

warning: field `allocator` is never read
   --> crates\nebula-memory\src\arena\allocator.rs:161:5
    |
157 | pub struct ArenaBackedVec<T, A: ArenaAllocate> {
    |            -------------- field in this struct
...
161 |     allocator: Arc<A>,
    |     ^^^^^^^^^

warning: associated function `new` is never used
   --> crates\nebula-memory\src\arena\arena.rs:290:19
    |
288 | impl<'a, T: ?Sized> ArenaRef<'a, T> {
    | ----------------------------------- associated function in this implementation
289 |     /// Creates a new reference from raw pointer
290 |     pub(crate) fn new(ptr: NonNull<T>, arena: &'a Arena) -> Self {
    |                   ^^^

warning: associated function `new` is never used
   --> crates\nebula-memory\src\arena\arena.rs:316:19
    |
314 | impl<'a, T: ?Sized> ArenaRefMut<'a, T> {
    | -------------------------------------- associated function in this implementation
315 |     /// Creates a new mutable reference from raw pointer
316 |     pub(crate) fn new(ptr: NonNull<T>, arena: &'a Arena) -> Self {
    |                   ^^^

warning: methods `record_deallocation` and `record_chunk_deallocation` are never used
   --> crates\nebula-memory\src\arena\stats.rs:161:19
    |
 51 | impl ArenaStats {
    | --------------- methods in this implementation
...
161 |     pub(crate) fn record_deallocation(&self, bytes: usize) {
    |                   ^^^^^^^^^^^^^^^^^^^
...
175 |     pub(crate) fn record_chunk_deallocation(&self, bytes: usize) {
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: associated function `new` is never used
   --> crates\nebula-memory\src\arena\thread_safe.rs:306:19
    |
304 | impl<'a, T: ?Sized + Sync> ThreadSafeArenaRef<'a, T> {
    | ---------------------------------------------------- associated function in this implementation
305 |     /// Creates a new thread-safe reference from raw pointer
306 |     pub(crate) fn new(ptr: NonNull<T>, arena: &'a ThreadSafeArena) -> Self {
    |                   ^^^

warning: struct `HierarchyStats` is never constructed
   --> crates\nebula-memory\src\pool\hierarchical.rs:200:12
    |
200 | pub struct HierarchyStats {
    |            ^^^^^^^^^^^^^^

warning: struct `PoolStatsSnapshot` is never constructed
   --> crates\nebula-memory\src\pool\hierarchical.rs:208:12
    |
208 | pub struct PoolStatsSnapshot {
    |            ^^^^^^^^^^^^^^^^^

warning: trait `HierarchicalPoolExt` is never used
   --> crates\nebula-memory\src\pool\hierarchical.rs:280:11
    |
280 | pub trait HierarchicalPoolExt<T: Poolable> {
    |           ^^^^^^^^^^^^^^^^^^^

warning: trait `PoolableBuilder` is never used
   --> crates\nebula-memory\src\pool\poolable.rs:181:11
    |
181 | pub trait PoolableBuilder: Poolable {
    |           ^^^^^^^^^^^^^^^

warning: struct `ThreadSafeComputeCache` is never constructed
   --> crates\nebula-memory\src\cache\compute.rs:634:12
    |
634 | pub struct ThreadSafeComputeCache<K, V>
    |            ^^^^^^^^^^^^^^^^^^^^^^

warning: multiple associated items are never used
   --> crates\nebula-memory\src\cache\compute.rs:648:12
    |
643 | / impl<K, V> ThreadSafeComputeCache<K, V>
644 | | where
645 | |     K: CacheKey,
646 | |     V: Clone,
    | |_____________- associated items in this implementation
647 |   {
648 |       pub fn new(max_entries: usize) -> Self {
    |              ^^^
...
654 |       pub fn with_config(config: CacheConfig) -> Self {
    |              ^^^^^^^^^^^
...
660 |       pub fn get_or_compute<F>(&self, key: K, compute_fn: F) -> CacheResult<V>
    |              ^^^^^^^^^^^^^^
...
668 |       pub fn get(&self, key: &K) -> Option<V> {
    |              ^^^
...
673 |       pub fn insert(&self, key: K, value: V) -> CacheResult<()> {
    |              ^^^^^^
...
678 |       pub fn contains_key(&self, key: &K) -> bool {
    |              ^^^^^^^^^^^^
...
683 |       pub fn remove(&self, key: &K) -> Option<V> {
    |              ^^^^^^
...
688 |       pub fn len(&self) -> usize {
    |              ^^^
...
693 |       pub fn clear(&self) {
    |              ^^^^^
...
698 |       pub fn metrics(&self) -> CacheMetrics {
    |              ^^^^^^^

warning: field `start_time` is never read
   --> crates\nebula-memory\src\cache\stats.rs:436:5
    |
407 | pub struct AtomicCacheStats {
    |            ---------------- field in this struct
...
436 |     start_time: SystemTime,
    |     ^^^^^^^^^^

warning: trait `CacheLevelExt` is never used
  --> crates\nebula-memory\src\cache\multi_level.rs:94:11
   |
94 | pub trait CacheLevelExt<K, V>: CacheLevel<K, V> {
   |           ^^^^^^^^^^^^^

warning: struct `ComputeCacheLevel` is never constructed
   --> crates\nebula-memory\src\cache\multi_level.rs:892:12
    |
892 | pub struct ComputeCacheLevel<K, V>
    |            ^^^^^^^^^^^^^^^^^

warning: associated functions `new` and `with_capacity` are never used
   --> crates\nebula-memory\src\cache\multi_level.rs:911:12
    |
905 | / impl<K, V> ComputeCacheLevel<K, V>
906 | | where
907 | |     K: CacheKey,
908 | |     V: Clone,
    | |_____________- associated functions in this implementation
...
911 |       pub fn new(name: &str, priority: usize, config: CacheConfig) -> Self {
    |              ^^^
...
920 |       pub fn with_capacity(name: &str, priority: usize, capacity: usize) -> Self {
    |              ^^^^^^^^^^^^^

warning: field `cache` is never read
   --> crates\nebula-memory\src\cache\scheduled.rs:713:5
    |
708 | struct DummyScheduledCache<K, V>
    |        ------------------- field in this struct
...
713 |     cache: Arc<RwLock<ComputeCache<K, V>>>,
    |     ^^^^^

warning: methods `len` and `cleanup_expired` are never used
   --> crates\nebula-memory\src\cache\scheduled.rs:722:8
    |
717 | / impl<K, V> DummyScheduledCache<K, V>
718 | | where
719 | |     K: CacheKey,
720 | |     V: Clone + Send + Sync + 'static,
    | |_____________________________________- methods in this implementation
721 |   {
722 |       fn len(&self) -> usize {
    |          ^^^
...
727 |       fn cleanup_expired(&self) -> usize {
    |          ^^^^^^^^^^^^^^^

warning: struct `CacheOptimizationTask` is never constructed
   --> crates\nebula-memory\src\cache\scheduled.rs:793:12
    |
793 | pub struct CacheOptimizationTask {
    |            ^^^^^^^^^^^^^^^^^^^^^

warning: associated items `new` and `with_priority` are never used
   --> crates\nebula-memory\src\cache\scheduled.rs:802:12
    |
801 | impl CacheOptimizationTask {
    | -------------------------- associated items in this implementation
802 |     pub fn new(interval: Duration, hit_rate_threshold: f64) -> Self {
    |            ^^^
...
811 |     pub fn with_priority(mut self, priority: TaskPriority) -> Self {
    |            ^^^^^^^^^^^^^

warning: struct `HealthMonitorTask` is never constructed
   --> crates\nebula-memory\src\cache\scheduled.rs:854:12
    |
854 | pub struct HealthMonitorTask {
    |            ^^^^^^^^^^^^^^^^^

warning: associated function `new` is never used
   --> crates\nebula-memory\src\cache\scheduled.rs:862:12
    |
861 | impl HealthMonitorTask {
    | ---------------------- associated function in this implementation
862 |     pub fn new(interval: Duration) -> Self {
    |            ^^^

warning: field `config` is never read
  --> crates\nebula-memory\src\cache\policies\random.rs:70:5
   |
63 | pub struct RandomPolicy<K, V>
   |            ------------ field in this struct
...
70 |     config: RandomConfig,
   |     ^^^^^^

warning: fields `hits`, `misses`, `requests`, and `last_reset` are never read
  --> crates\nebula-memory\src\cache\policies\adaptive.rs:52:5
   |
50 | struct PolicyMetrics {
   |        ------------- fields in this struct
51 |     /// Number of cache hits
52 |     hits: usize,
   |     ^^^^
53 |     /// Number of cache misses
54 |     misses: usize,
   |     ^^^^^^
55 |     /// Total number of requests
56 |     requests: usize,
   |     ^^^^^^^^
...
59 |     last_reset: Instant,
   |     ^^^^^^^^^^
   |
   = note: `PolicyMetrics` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `record_hit`, `record_miss`, `hit_rate`, and `reset` are never used
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:108:8
    |
 85 | impl PolicyMetrics {
    | ------------------ methods in this implementation
...
108 |     fn record_hit(&mut self) {
    |        ^^^^^^^^^^
...
114 |     fn record_miss(&mut self) {
    |        ^^^^^^^^^^^
...
120 |     fn hit_rate(&self) -> f64 {
    |        ^^^^^^^^
...
129 |     fn reset(&mut self) {
    |        ^^^^^

warning: struct `EvictionEntry` is never constructed
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:147:12
    |
147 | pub struct EvictionEntry<'a, K, V> {
    |            ^^^^^^^^^^^^^

warning: associated function `new` is never used
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:153:12
    |
152 | impl<'a, K, V> EvictionEntry<'a, K, V> {
    | -------------------------------------- associated function in this implementation
153 |     pub fn new(key: &'a K, entry: &'a CacheEntry<V>) -> Self {
    |            ^^^

warning: trait `VictimSelector` is never used
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:159:11
    |
159 | pub trait VictimSelector<K, V> {
    |           ^^^^^^^^^^^^^^

warning: trait `EvictionPolicy` is never used
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:164:11
    |
164 | pub trait EvictionPolicy<K, V>: VictimSelector<K, V> {
    |           ^^^^^^^^^^^^^^

warning: fields `lru`, `lfu`, `metrics`, and `last_evaluation` are never read
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:183:5
    |
174 | pub struct AdaptivePolicy<K, V>
    |            -------------- fields in this struct
...
183 |     lru: LruPolicy<K, V>,
    |     ^^^
184 |     /// LFU policy instance
185 |     lfu: LfuPolicy<K, V>,
    |     ^^^
...
189 |     metrics: HashMap<PolicyType, PolicyMetrics>,
    |     ^^^^^^^
...
197 |     last_evaluation: Instant,
    |     ^^^^^^^^^^^^^^^

warning: methods `evaluate_shadow_hit`, `update_shadow_metrics`, `evaluate_policies`, and `perform_policy_evaluation` are never used
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:284:8
    |
209 | / impl<K, V> AdaptivePolicy<K, V>
210 | | where
211 | |     K: CacheKey,
    | |________________- methods in this implementation
...
284 |       fn evaluate_shadow_hit(&self, key: &K) -> HashMap<PolicyType, bool> {
    |          ^^^^^^^^^^^^^^^^^^^
...
297 |       fn update_shadow_metrics(&mut self, key: &K, actual_hit: bool) {
    |          ^^^^^^^^^^^^^^^^^^^^^
...
311 |       fn evaluate_policies(&mut self) {
    |          ^^^^^^^^^^^^^^^^^
...
334 |       fn perform_policy_evaluation(&mut self) {
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: trait `PolicyExtensions` is never used
   --> crates\nebula-memory\src\cache\policies\adaptive.rs:507:7
    |
507 | trait PolicyExtensions<K> {
    |       ^^^^^^^^^^^^^^^^

warning: fields `count` and `weight` are never read
   --> crates\nebula-memory\src\cache\policies\lfu.rs:112:5
    |
107 | struct AccessRecord {
    |        ------------ fields in this struct
...
112 |     count: u64,
    |     ^^^^^
113 |     /// Weight for this access (for decay calculations)
114 |     weight: f64,
    |     ^^^^^^
    |
    = note: `AccessRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `frequency` and `prev` are never read
   --> crates\nebula-memory\src\cache\policies\lfu.rs:121:5
    |
119 | struct FrequencyBucket<K> {
    |        --------------- fields in this struct
120 |     /// Frequency value
121 |     frequency: u64,
    |     ^^^^^^^^^
...
127 |     prev: Option<u64>,
    |     ^^^^
    |
    = note: `FrequencyBucket` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `access_count`, `last_access`, and `protected` are never read
   --> crates\nebula-memory\src\cache\policies\lru.rs:104:5
    |
100 | struct LruNode<K> {
    |        ------- fields in this struct
...
104 |     access_count: u64,
    |     ^^^^^^^^^^^^
...
107 |     last_access: Instant,
    |     ^^^^^^^^^^^
108 |     protected: bool, // For protection against single-scan sequences
    |     ^^^^^^^^^
    |
    = note: `LruNode` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: methods `move_to_front` and `is_empty` are never used
   --> crates\nebula-memory\src\cache\policies\lru.rs:190:8
    |
134 | impl<K> DoublyLinkedList<K> {
    | --------------------------- methods in this implementation
...
190 |     fn move_to_front(&mut self, node: NonNull<LruNode<K>>) {
    |        ^^^^^^^^^^^^^
...
218 |     fn is_empty(&self) -> bool {
    |        ^^^^^^^^

warning: field `access_threshold` is never read
   --> crates\nebula-memory\src\cache\policies\lru.rs:235:5
    |
231 | struct LruSegment<K> {
    |        ---------- field in this struct
...
235 |     access_threshold: u64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `LruSegment` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: methods `access` and `should_promote` are never used
   --> crates\nebula-memory\src\cache\policies\lru.rs:271:8
    |
238 | / impl<K> LruSegment<K>
239 | | where
240 | |     K: CacheKey,
    | |________________- methods in this implementation
...
271 |       fn access(&mut self, key: &K) -> bool {
    |          ^^^^^^
...
305 |       fn should_promote(&self, key: &K) -> bool {
    |          ^^^^^^^^^^^^^^

warning: field `size` is never read
   --> crates\nebula-memory\src\cache\policies\lru.rs:325:5
    |
321 | struct ClockItem<K> {
    |        --------- field in this struct
...
325 |     size: usize,
    |     ^^^^
    |
    = note: `ClockItem` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `find_victim` and `access` are never used
   --> crates\nebula-memory\src\cache\policies\lru.rs:348:8
    |
328 | / impl<K> ClockHand<K>
329 | | where
330 | |     K: CacheKey,
    | |________________- methods in this implementation
...
348 |       fn find_victim(&mut self) -> Option<K> {
    |          ^^^^^^^^^^^
...
370 |       fn access(&mut self, key: &K) {
    |          ^^^^^^

warning: field `hot_capacity` is never read
   --> crates\nebula-memory\src\cache\policies\lru.rs:447:9
    |
442 |     Adaptive {
    |     -------- field in this variant
...
447 |         hot_capacity: usize,
    |         ^^^^^^^^^^^^
    |
    = note: `LruStrategyImpl` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: multiple methods are never used
   --> crates\nebula-memory\src\cache\policies\lru.rs:817:8
    |
456 | / impl<K, V> LruPolicy<K, V>
457 | | where
458 | |     K: CacheKey,
    | |________________- methods in this implementation
...
817 |       fn classic_access(
    |          ^^^^^^^^^^^^^^
...
839 |       fn classic_insert(
    |          ^^^^^^^^^^^^^^
...
853 |       fn segmented_access(
    |          ^^^^^^^^^^^^^^^^
...
875 |       fn clock_access(
    |          ^^^^^^^^^^^^
...
884 |       fn adaptive_access(
    |          ^^^^^^^^^^^^^^^
...
926 |       fn adaptive_insert(
    |          ^^^^^^^^^^^^^^^
...
939 |       fn multi_queue_access(
    |          ^^^^^^^^^^^^^^^^^^

warning: methods `is_expired` and `record_insertion_time` are never used
  --> crates\nebula-memory\src\cache\policies\ttl.rs:70:8
   |
41 | / impl<K> TtlPolicy<K>
42 | | where
43 | |     K: CacheKey,
   | |________________- methods in this implementation
...
70 |       fn is_expired(&self, key: &K) -> bool {
   |          ^^^^^^^^^^
...
81 |       fn record_insertion_time(&mut self, key: &K) {
   |          ^^^^^^^^^^^^^^^^^^^^^

warning: method `average_usage` is never used
   --> crates\nebula-memory\src\budget\budget.rs:160:8
    |
127 | impl UsageHistory {
    | ----------------- method in this implementation
...
160 |     fn average_usage(&self) -> Option<usize> {
    |        ^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\allocator\error.rs:139:5
    |
139 |     pub fn message(&self) -> &'static str {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the lint level is defined here
   --> crates\nebula-memory\src\lib.rs:51:9
    |
 51 | #![warn(missing_docs)]
    |         ^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\allocator\error.rs:155:5
    |
155 |     pub fn severity(&self) -> Severity {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\allocator\error.rs:271:5
    |
271 |     pub fn get_stats(&self) -> ErrorStatsSnapshot {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\allocator\error.rs:285:5
    |
285 |     pub fn reset(&self) {
    |     ^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct
   --> crates\nebula-memory\src\allocator\error.rs:299:1
    |
299 | pub struct ErrorStatsSnapshot {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:300:5
    |
300 |     pub out_of_memory: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:301:5
    |
301 |     pub size_overflow: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:302:5
    |
302 |     pub invalid_alignment: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:303:5
    |
303 |     pub exceeds_max_size: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:304:5
    |
304 |     pub invalid_layout: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:305:5
    |
305 |     pub invalid_state: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:306:5
    |
306 |     pub concurrent_access: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:307:5
    |
307 |     pub resource_limit: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\allocator\error.rs:308:5
    |
308 |     pub total_errors: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\allocator\error.rs:332:5
    |
332 |     pub const fn new() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\allocator\error.rs:342:5
    |
342 |     pub fn capture() -> Option<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a macro
   --> crates\nebula-memory\src\allocator\manager.rs:374:1
    |
374 | macro_rules! set_active_allocator {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
  --> crates\nebula-memory\src\allocator\bump\config.rs:11:5
   |
11 |     pub dealloc_pattern: Option<u8>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
  --> crates\nebula-memory\src\allocator\bump\config.rs:15:5
   |
15 |     pub prefetch_distance: usize,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
  --> crates\nebula-memory\src\allocator\pool\config.rs:11:5
   |
11 |     pub dealloc_pattern: Option<u8>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\allocator\stack\allocator.rs:286:5
    |
286 |     pub fn medium() -> AllocResult<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\allocator\stack\allocator.rs:289:5
    |
289 |     pub fn large() -> AllocResult<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
  --> crates\nebula-memory\src\allocator\stack\config.rs:11:5
   |
11 |     pub dealloc_pattern: Option<u8>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\utils.rs:208:5
    |
208 |     pub fn new(name: &'static str) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\utils.rs:216:5
    |
216 |     pub fn elapsed(&self) -> Duration {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\utils.rs:220:5
    |
220 |     pub fn print(&self) {
    |     ^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\arena\cross_thread.rs:173:5
    |
173 |     pub fn new() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\cross_thread.rs:179:5
    |
179 |     pub fn initial_size(mut self, size: usize) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\cross_thread.rs:184:5
    |
184 |     pub fn growth_factor(mut self, factor: f64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\cross_thread.rs:189:5
    |
189 |     pub fn max_chunk_size(mut self, size: usize) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\cross_thread.rs:194:5
    |
194 |     pub fn track_stats(mut self, enabled: bool) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\cross_thread.rs:199:5
    |
199 |     pub fn zero_memory(mut self, enabled: bool) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\cross_thread.rs:204:5
    |
204 |     pub fn build(self) -> CrossThreadArena {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:58:5
   |
58 |     pub fn bytes_allocated(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:62:5
   |
62 |     pub fn bytes_used(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:66:5
   |
66 |     pub fn bytes_wasted(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:70:5
   |
70 |     pub fn bytes_available(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:74:5
   |
74 |     pub fn allocations(&self) -> u64 {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:78:5
   |
78 |     pub fn deallocations(&self) -> u64 {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:82:5
   |
82 |     pub fn resets(&self) -> u64 {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:86:5
   |
86 |     pub fn chunks_allocated(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:90:5
   |
90 |     pub fn current_chunks(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
  --> crates\nebula-memory\src\arena\stats.rs:94:5
   |
94 |     pub fn max_chunks(&self) -> usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:248:5
    |
248 |     pub bytes_allocated: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:249:5
    |
249 |     pub bytes_used: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:250:5
    |
250 |     pub bytes_wasted: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:251:5
    |
251 |     pub bytes_available: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:252:5
    |
252 |     pub allocations: u64,
    |     ^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:253:5
    |
253 |     pub deallocations: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:254:5
    |
254 |     pub resets: u64,
    |     ^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:255:5
    |
255 |     pub chunks_allocated: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:256:5
    |
256 |     pub current_chunks: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:257:5
    |
257 |     pub max_chunks: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:258:5
    |
258 |     pub fragmentation_ratio: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:259:5
    |
259 |     pub utilization_ratio: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:260:5
    |
260 |     pub average_allocation_size: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:261:5
    |
261 |     pub average_allocation_time: Duration,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:262:5
    |
262 |     pub average_reset_time: Duration,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\arena\stats.rs:263:5
    |
263 |     pub uptime: Duration,
    |     ^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\arena\typed.rs:289:5
    |
289 |     pub fn new(value: &'a T) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct
   --> crates\nebula-memory\src\arena\macros.rs:395:1
    |
395 | pub struct StrictArena<A> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\arena\macros.rs:400:5
    |
400 |     pub fn new(arena: A) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\macros.rs:406:5
    |
406 |     pub fn alloc<T>(&self, value: T) -> &mut T {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\arena\macros.rs:410:5
    |
410 | /     pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]
411 | |     where
412 | |         T: Copy,
    | |________________^

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\batch.rs:249:17
    |
249 |     pub fn iter(&self) -> core::slice::Iter<T> {
    |                 ^^^^^     -------------------- the same lifetime is hidden here
    |                 |
    |                 the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
    = note: `#[warn(mismatched_lifetime_syntaxes)]` on by default
help: use `'_` for type paths
    |
249 |     pub fn iter(&self) -> core::slice::Iter<'_, T> {
    |                                             +++

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\batch.rs:254:21
    |
254 |     pub fn iter_mut(&mut self) -> core::slice::IterMut<T> {
    |                     ^^^^^^^^^     ----------------------- the same lifetime is hidden here
    |                     |
    |                     the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: use `'_` for type paths
    |
254 |     pub fn iter_mut(&mut self) -> core::slice::IterMut<'_, T> {
    |                                                        +++

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:249:5
    |
249 |     pub total_checkouts: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:250:5
    |
250 |     pub total_returns: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:251:5
    |
251 |     pub total_failures: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:252:5
    |
252 |     pub leaked_objects: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:253:5
    |
253 |     pub pool_capacity: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:254:5
    |
254 |     pub available_objects: usize,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\pool\health.rs:255:5
    |
255 |     pub health_status: PoolHealth,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\lockfree.rs:159:16
    |
159 |     pub fn get(&self) -> MemoryResult<LockFreePooledValue<T>> {
    |                ^^^^^                  ---------------------- the same lifetime is hidden here
    |                |
    |                the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: use `'_` for type paths
    |
159 |     pub fn get(&self) -> MemoryResult<LockFreePooledValue<'_, T>> {
    |                                                           +++

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\lockfree.rs:206:20
    |
206 |     pub fn try_get(&self) -> Option<LockFreePooledValue<T>> {
    |                    ^^^^^            ---------------------- the same lifetime is hidden here
    |                    |
    |                    the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: use `'_` for type paths
    |
206 |     pub fn try_get(&self) -> Option<LockFreePooledValue<'_, T>> {
    |                                                         +++

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\thread_safe.rs:118:16
    |
118 |     pub fn get(&self) -> MemoryResult<ThreadSafePooledValue<T>> {
    |                ^^^^^                  ------------------------ the same lifetime is hidden here
    |                |
    |                the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: use `'_` for type paths
    |
118 |     pub fn get(&self) -> MemoryResult<ThreadSafePooledValue<'_, T>> {
    |                                                             +++

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\thread_safe.rs:123:20
    |
123 |     pub fn try_get(&self) -> Option<ThreadSafePooledValue<T>> {
    |                    ^^^^^            ------------------------ the same lifetime is hidden here
    |                    |
    |                    the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: use `'_` for type paths
    |
123 |     pub fn try_get(&self) -> Option<ThreadSafePooledValue<'_, T>> {
    |                                                           +++

warning: hiding a lifetime that's elided elsewhere is confusing
   --> crates\nebula-memory\src\pool\thread_safe.rs:154:24
    |
154 |     pub fn get_timeout(&self, timeout: Option<Duration>) -> MemoryResult<ThreadSafePooledValue<T>> {
    |                        ^^^^^ the lifetime is elided here                 ------------------------ the same lifetime is hidden here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: use `'_` for type paths
    |
154 |     pub fn get_timeout(&self, timeout: Option<Duration>) -> MemoryResult<ThreadSafePooledValue<'_, T>> {
    |                                                                                                +++

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:116:5
    |
116 |     pub hits: u64,
    |     ^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:117:5
    |
117 |     pub misses: u64,
    |     ^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:118:5
    |
118 |     pub evictions: u64,
    |     ^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:119:5
    |
119 |     pub insertions: u64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:120:5
    |
120 |     pub updates: u64,
    |     ^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:121:5
    |
121 |     pub deletions: u64,
    |     ^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:122:5
    |
122 |     pub expired_entries: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:125:5
    |
125 |     pub total_compute_time_ns: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:126:5
    |
126 |     pub total_lookup_time_ns: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:127:5
    |
127 |     pub total_insertion_time_ns: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:128:5
    |
128 |     pub total_eviction_time_ns: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:131:5
    |
131 |     pub size_bytes: u64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:132:5
    |
132 |     pub max_size_bytes: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:133:5
    |
133 |     pub entry_count: u64,
    |     ^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:134:5
    |
134 |     pub max_entries: u64,
    |     ^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:135:5
    |
135 |     pub peak_entry_count: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:136:5
    |
136 |     pub peak_size_bytes: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:139:5
    |
139 |     pub cache_efficiency_score: f64, // 0.0 to 100.0
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:140:5
    |
140 |     pub memory_pressure: f64,        // 0.0 to 1.0
    |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:141:5
    |
141 |     pub fragmentation_ratio: f64,    // 0.0 to 1.0
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:142:5
    |
142 |     pub load_factor: f64,            // 0.0 to 1.0
    |     ^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:146:5
    |
146 |     pub start_time: SystemTime,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:148:5
    |
148 |     pub last_reset: SystemTime,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:151:5
    |
151 |     pub allocation_failures: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:152:5
    |
152 |     pub timeout_errors: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:153:5
    |
153 |     pub corruption_errors: u64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:156:5
    |
156 |     pub key_size_distribution: SizeDistribution,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:157:5
    |
157 |     pub value_size_distribution: SizeDistribution,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a struct field
   --> crates\nebula-memory\src\cache\stats.rs:158:5
    |
158 |     pub access_pattern: AccessPattern,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for an associated function
   --> crates\nebula-memory\src\cache\scheduled.rs:743:5
    |
743 |     pub fn new(interval: Duration) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: missing documentation for a method
   --> crates\nebula-memory\src\cache\scheduled.rs:751:5
    |
751 |     pub fn with_priority(mut self, priority: TaskPriority) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused return value of `Box::<T>::from_raw` that must be used
   --> crates\nebula-memory\src\cache\policies\lru.rs:643:25
    |
643 |                         Box::from_raw(node_ptr.as_ptr());
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`
    = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
    |
643 |                         let _ = Box::from_raw(node_ptr.as_ptr());
    |                         +++++++

warning: unused return value of `Box::<T>::from_raw` that must be used
   --> crates\nebula-memory\src\cache\policies\lru.rs:667:25
    |
667 |                         Box::from_raw(node_ptr.as_ptr());
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`
help: use `let _ = ...` to ignore the resulting value
    |
667 |                         let _ = Box::from_raw(node_ptr.as_ptr());
    |                         +++++++

warning: unused return value of `Box::<T>::from_raw` that must be used
   --> crates\nebula-memory\src\cache\policies\lru.rs:672:25
    |
672 |                         Box::from_raw(node_ptr.as_ptr());
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`
help: use `let _ = ...` to ignore the resulting value
    |
672 |                         let _ = Box::from_raw(node_ptr.as_ptr());
    |                         +++++++

warning: `nebula-memory` (lib) generated 194 warnings (run `cargo fix --lib -p nebula-memory` to apply 2 suggestions)
    Finished `bench` profile [optimized] target(s) in 0.20s
     Running benches\baseline.rs (C:\Users\vanya\RustroverProjects\nebula\target\release\deps\baseline-4f4af0c05d19190d.exe)
Gnuplot not found, using plotters backend
Benchmarking template/parse/simple
Benchmarking template/parse/simple: Warming up for 3.0000 s
Benchmarking template/parse/simple: Collecting 100 samples in estimated 5.0012 s (15M iterations)
Benchmarking template/parse/simple: Analyzing
template/parse/simple   time:   [338.33 ns 338.84 ns 339.36 ns]
                        change: [+0.1486% +0.4628% +0.7940%] (p = 0.00 < 0.05)
                        Change within noise threshold.
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) low mild
  3 (3.00%) high mild
Benchmarking template/parse/multiple_expressions
Benchmarking template/parse/multiple_expressions: Warming up for 3.0000 s
Benchmarking template/parse/multiple_expressions: Collecting 100 samples in estimated 5.0005 s (10.0M iterations)
Benchmarking template/parse/multiple_expressions: Analyzing
template/parse/multiple_expressions
                        time:   [501.72 ns 502.70 ns 503.74 ns]
                        change: [+0.7163% +1.1859% +1.6388%] (p = 0.00 < 0.05)
                        Change within noise threshold.
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  3 (3.00%) high mild
  1 (1.00%) high severe
Benchmarking template/parse/complex
Benchmarking template/parse/complex: Warming up for 3.0000 s
Benchmarking template/parse/complex: Collecting 100 samples in estimated 5.0063 s (4.0M iterations)
Benchmarking template/parse/complex: Analyzing
template/parse/complex  time:   [1.2482 µs 1.2512 µs 1.2546 µs]
                        change: [+0.2918% +0.8786% +1.3728%] (p = 0.00 < 0.05)
                        Change within noise threshold.
Found 3 outliers among 100 measurements (3.00%)
  1 (1.00%) low mild
  2 (2.00%) high mild

Benchmarking template/render/simple
Benchmarking template/render/simple: Warming up for 3.0000 s
Benchmarking template/render/simple: Collecting 100 samples in estimated 5.0009 s (26M iterations)
Benchmarking template/render/simple: Analyzing
template/render/simple  time:   [194.20 ns 194.61 ns 195.06 ns]
                        change: [+6.4137% +6.7890% +7.1842%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 6 outliers among 100 measurements (6.00%)
  3 (3.00%) high mild
  3 (3.00%) high severe
Benchmarking template/render/complex
Benchmarking template/render/complex: Warming up for 3.0000 s
Benchmarking template/render/complex: Collecting 100 samples in estimated 5.0043 s (5.7M iterations)
Benchmarking template/render/complex: Analyzing
template/render/complex time:   [875.67 ns 877.20 ns 878.79 ns]
                        change: [+5.0438% +5.4494% +5.8160%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 5 outliers among 100 measurements (5.00%)
  5 (5.00%) high severe

Benchmarking template/clone
Benchmarking template/clone: Warming up for 3.0000 s
Benchmarking template/clone: Collecting 100 samples in estimated 5.0001 s (77M iterations)
Benchmarking template/clone: Analyzing
template/clone          time:   [68.000 ns 69.983 ns 72.256 ns]
                        change: [+4.3418% +6.0090% +7.7308%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 11 outliers among 100 measurements (11.00%)
  4 (4.00%) high mild
  7 (7.00%) high severe

Benchmarking engine/evaluate_no_cache/literal
Benchmarking engine/evaluate_no_cache/literal: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/literal: Collecting 100 samples in estimated 5.0002 s (52M iterations)
Benchmarking engine/evaluate_no_cache/literal: Analyzing
engine/evaluate_no_cache/literal
                        time:   [94.724 ns 94.941 ns 95.193 ns]
                        change: [+5.9621% +6.2497% +6.5139%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) low mild
  3 (3.00%) high mild
Benchmarking engine/evaluate_no_cache/arithmetic
Benchmarking engine/evaluate_no_cache/arithmetic: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/arithmetic: Collecting 100 samples in estimated 5.0007 s (14M iterations)
Benchmarking engine/evaluate_no_cache/arithmetic: Analyzing
engine/evaluate_no_cache/arithmetic
                        time:   [348.25 ns 348.91 ns 349.58 ns]
                        change: [+6.6571% +6.9584% +7.2642%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 6 outliers among 100 measurements (6.00%)
  1 (1.00%) low mild
  3 (3.00%) high mild
  2 (2.00%) high severe
Benchmarking engine/evaluate_no_cache/comparison
Benchmarking engine/evaluate_no_cache/comparison: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/comparison: Collecting 100 samples in estimated 5.0006 s (24M iterations)
Benchmarking engine/evaluate_no_cache/comparison: Analyzing
engine/evaluate_no_cache/comparison
                        time:   [206.13 ns 206.43 ns 206.73 ns]
                        change: [+2.1752% +3.8188% +5.2065%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 6 outliers among 100 measurements (6.00%)
  2 (2.00%) low mild
  2 (2.00%) high mild
  2 (2.00%) high severe
Benchmarking engine/evaluate_no_cache/string_concat
Benchmarking engine/evaluate_no_cache/string_concat: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/string_concat: Collecting 100 samples in estimated 5.0011 s (5.9M iterations)
Benchmarking engine/evaluate_no_cache/string_concat: Analyzing
engine/evaluate_no_cache/string_concat
                        time:   [842.23 ns 843.75 ns 845.32 ns]
                        change: [+7.0079% +7.5551% +8.1442%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 6 outliers among 100 measurements (6.00%)
  2 (2.00%) low mild
  2 (2.00%) high mild
  2 (2.00%) high severe
Benchmarking engine/evaluate_no_cache/function_call
Benchmarking engine/evaluate_no_cache/function_call: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/function_call: Collecting 100 samples in estimated 5.0007 s (11M iterations)
Benchmarking engine/evaluate_no_cache/function_call: Analyzing
engine/evaluate_no_cache/function_call
                        time:   [459.43 ns 460.40 ns 461.42 ns]
                        change: [-0.6266% +1.7817% +3.8197%] (p = 0.12 > 0.05)
                        No change in performance detected.
Found 6 outliers among 100 measurements (6.00%)
  2 (2.00%) low mild
  3 (3.00%) high mild
  1 (1.00%) high severe
Benchmarking engine/evaluate_no_cache/nested
Benchmarking engine/evaluate_no_cache/nested: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/nested: Collecting 100 samples in estimated 5.0028 s (7.8M iterations)
Benchmarking engine/evaluate_no_cache/nested: Analyzing
engine/evaluate_no_cache/nested
                        time:   [638.29 ns 639.75 ns 641.36 ns]
                        change: [+11.033% +11.419% +11.821%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 3 outliers among 100 measurements (3.00%)
  2 (2.00%) high mild
  1 (1.00%) high severe
Benchmarking engine/evaluate_no_cache/conditional
Benchmarking engine/evaluate_no_cache/conditional: Warming up for 3.0000 s
Benchmarking engine/evaluate_no_cache/conditional: Collecting 100 samples in estimated 5.0010 s (14M iterations)
Benchmarking engine/evaluate_no_cache/conditional: Analyzing
engine/evaluate_no_cache/conditional
                        time:   [363.30 ns 363.86 ns 364.44 ns]
                        change: [+7.9058% +8.2582% +8.5980%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 4 outliers among 100 measurements (4.00%)
  2 (2.00%) low mild
  2 (2.00%) high mild

Benchmarking engine/evaluate_with_cache/cache_hit
Benchmarking engine/evaluate_with_cache/cache_hit: Warming up for 3.0000 s
Benchmarking engine/evaluate_with_cache/cache_hit: Collecting 100 samples in estimated 5.0008 s (21M iterations)
Benchmarking engine/evaluate_with_cache/cache_hit: Analyzing
engine/evaluate_with_cache/cache_hit
                        time:   [237.21 ns 237.76 ns 238.34 ns]
                        change: [+2.8126% +3.1134% +3.4299%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 6 outliers among 100 measurements (6.00%)
  2 (2.00%) low mild
  4 (4.00%) high mild
Benchmarking engine/evaluate_with_cache/cache_miss
Benchmarking engine/evaluate_with_cache/cache_miss: Warming up for 3.0000 s
Benchmarking engine/evaluate_with_cache/cache_miss: Collecting 100 samples in estimated 5.0021 s (2.5M iterations)
Benchmarking engine/evaluate_with_cache/cache_miss: Analyzing
engine/evaluate_with_cache/cache_miss
                        time:   [1.9709 µs 1.9772 µs 1.9830 µs]
                        change: [+1.0164% +2.3208% +3.7163%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 2 outliers among 100 measurements (2.00%)
  1 (1.00%) low severe
  1 (1.00%) high mild

Benchmarking context/operations/clone_100_vars
Benchmarking context/operations/clone_100_vars: Warming up for 3.0000 s
Benchmarking context/operations/clone_100_vars: Collecting 100 samples in estimated 5.0058 s (3.2M iterations)
Benchmarking context/operations/clone_100_vars: Analyzing
context/operations/clone_100_vars
                        time:   [1.5414 µs 1.5452 µs 1.5493 µs]
                        change: [+4.7181% +4.9803% +5.2376%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 3 outliers among 100 measurements (3.00%)
  3 (3.00%) high mild
Benchmarking context/operations/lookup
Benchmarking context/operations/lookup: Warming up for 3.0000 s
Benchmarking context/operations/lookup: Collecting 100 samples in estimated 5.0000 s (334M iterations)
Benchmarking context/operations/lookup: Analyzing
context/operations/lookup
                        time:   [15.312 ns 15.847 ns 16.482 ns]
                        change: [+4.8909% +7.1208% +10.093%] (p = 0.00 < 0.05)
                        Performance has regressed.
Found 12 outliers among 100 measurements (12.00%)
  4 (4.00%) high mild
  8 (8.00%) high severe

Benchmarking concurrent/access/1_thread
Benchmarking concurrent/access/1_thread: Warming up for 3.0000 s
Benchmarking concurrent/access/1_thread: Collecting 100 samples in estimated 5.0005 s (30M iterations)
Benchmarking concurrent/access/1_thread: Analyzing
concurrent/access/1_thread
                        time:   [167.96 ns 171.69 ns 176.30 ns]
                        thrpt:  [5.6722 Melem/s 5.8244 Melem/s 5.9539 Melem/s]
                 change:
                        time:   [+4.6510% +6.7307% +8.9707%] (p = 0.00 < 0.05)
                        thrpt:  [-8.2322% -6.3062% -4.4443%]
                        Performance has regressed.
Found 11 outliers among 100 measurements (11.00%)
  11 (11.00%) high severe
Benchmarking concurrent/access/2_threads
Benchmarking concurrent/access/2_threads: Warming up for 3.0000 s
error: bench failed, to rerun pass `--bench baseline`

Caused by:
  process didn't exit successfully: `C:\Users\vanya\RustroverProjects\nebula\target\release\deps\baseline-4f4af0c05d19190d.exe --bench` (exit code: 143)

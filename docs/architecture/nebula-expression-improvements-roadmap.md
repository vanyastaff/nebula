# Nebula Expression - Roadmap –ø–æ —É–ª—É—á—à–µ–Ω–∏—è–º

## üìã –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ

- [Executive Summary](#executive-summary)
- [–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã (P0)](#–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ-–ø—Ä–æ–±–ª–µ–º—ã-p0)
- [–í–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã (P1)](#–≤–∞–∂–Ω—ã–µ-–ø—Ä–æ–±–ª–µ–º—ã-p1)
- [–ñ–µ–ª–∞—Ç–µ–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è (P2)](#–∂–µ–ª–∞—Ç–µ–ª—å–Ω—ã–µ-—É–ª—É—á—à–µ–Ω–∏—è-p2)
- [Nice-to-have (P3)](#nice-to-have-p3)
- [–ü–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏](#–ø–ª–∞–Ω-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏)
- [–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞](#–º–µ—Ç—Ä–∏–∫–∏-—É—Å–ø–µ—Ö–∞)

---

## Executive Summary

### üî• –ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å

–ò–∑ **160+ –≤—ã—è–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º**:
- üî¥ **P0 (–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ)**: 12 –ø—Ä–æ–±–ª–µ–º - —Ç—Ä–µ–±—É—é—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è
- üü° **P1 (–í–∞–∂–Ω—ã–µ)**: 23 –ø—Ä–æ–±–ª–µ–º—ã - —Ä–µ—à–∏—Ç—å –≤ —Ç–µ—á–µ–Ω–∏–µ –º–µ—Å—è—Ü–∞
- üü¢ **P2 (–ñ–µ–ª–∞—Ç–µ–ª—å–Ω—ã–µ)**: 45 –ø—Ä–æ–±–ª–µ–º - —Ä–µ—à–∏—Ç—å –≤ —Ç–µ—á–µ–Ω–∏–µ –∫–≤–∞—Ä—Ç–∞–ª–∞
- ‚ö™ **P3 (Nice-to-have)**: 80+ –ø—Ä–æ–±–ª–µ–º - –ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

### üìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º

```
Performance:  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 45 –ø—Ä–æ–±–ª–µ–º (28%)
Memory:       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 38 –ø—Ä–æ–±–ª–µ–º (24%)
Architecture: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 22 –ø—Ä–æ–±–ª–µ–º—ã (14%)
API Design:   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 18 –ø—Ä–æ–±–ª–µ–º (11%)
Error Handle: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 15 –ø—Ä–æ–±–ª–µ–º (9%)
Testing:      ‚ñà‚ñà‚ñà‚ñà‚ñà 12 –ø—Ä–æ–±–ª–µ–º (7%)
Docs:         ‚ñà‚ñà‚ñà 10 –ø—Ä–æ–±–ª–µ–º (6%)
```

### üéØ –û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

–ü–æ—Å–ª–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ P0-P1:
- ‚¨ÜÔ∏è **8-10x** –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (concurrent access)
- ‚¨áÔ∏è **70-80%** memory allocations
- ‚¨áÔ∏è **50-60%** memory usage
- ‚¨ÜÔ∏è **5x** throughput
- ‚úÖ Zero breaking changes (–±–ª–∞–≥–æ–¥–∞—Ä—è –ø—Ä–∏–≤–∞—Ç–∏–∑–∞—Ü–∏–∏ –º–æ–¥—É–ª–µ–π)

---

## –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã (P0)

> üéØ **–¶–µ–ª—å**: –†–µ—à–∏—Ç—å –∑–∞ **1-2 –Ω–µ–¥–µ–ª–∏**
>
> üí∞ **ROI**: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π (–≤—ã—Å–æ–∫–∞—è –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å + –Ω–∏–∑–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)

### P0.1: Template Zero-Copy ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: String –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –≤ –∫–∞–∂–¥–æ–º TemplatePart

**Impact**:
- üî¥ Memory: ~70% –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö –∞–ª–ª–æ–∫–∞—Ü–∏–π
- üî¥ Performance: ~40% –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ cloning

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –î–æ
pub enum TemplatePart {
    Static { content: String, ... },
    Expression { content: String, ... },
}

pub struct Template {
    source: String,
    parts: Vec<TemplatePart>,
}

// –ü–æ—Å–ª–µ
use std::borrow::Cow;
use smallvec::SmallVec;

pub enum TemplatePart<'a> {
    Static { content: Cow<'a, str>, ... },
    Expression { content: Cow<'a, str>, ... },
}

pub struct Template<'a> {
    source: Cow<'a, str>,
    parts: SmallVec<[TemplatePart<'a>; 8]>,
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å lifetime –ø–∞—Ä–∞–º–µ—Ç—Ä –∫ `TemplatePart` (30 –º–∏–Ω)
2. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å `String` –Ω–∞ `Cow<'a, str>` (1 —á–∞—Å)
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `smallvec` dependency (5 –º–∏–Ω)
4. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å `Vec` –Ω–∞ `SmallVec<[...; 8]>` (30 –º–∏–Ω)
5. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å API: `Template::new()` –ø—Ä–∏–Ω–∏–º–∞–µ—Ç `impl Into<Cow<'a, str>>` (30 –º–∏–Ω)
6. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã –¥–ª—è borrowed –∏ owned variants (1 —á–∞—Å)
7. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ (30 –º–∏–Ω)

**–í—Ä–µ–º—è**: 4 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç (API –æ—Å—Ç–∞–µ—Ç—Å—è —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º)

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚¨áÔ∏è Allocations: —Å ~10 –¥–æ ~2 –Ω–∞ –ø—Ä–æ—Å—Ç–æ–π —à–∞–±–ª–æ–Ω
- ‚¨áÔ∏è Memory: —Å ~500 bytes –¥–æ ~150 bytes
- ‚¨ÜÔ∏è Parse speed: ~5x –±—ã—Å—Ç—Ä–µ–µ

---

### P0.2: Engine RwLock + Arc<str> keys ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: `Arc<Mutex<Cache<String, T>>>` - contention + –∞–ª–ª–æ–∫–∞—Ü–∏–∏

**Impact**:
- üî¥ Performance: 7.5x –º–µ–¥–ª–µ–Ω–Ω–µ–µ –ø—Ä–∏ concurrent access
- üî¥ Memory: String –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –ø—Ä–∏ –∫–∞–∂–¥–æ–º lookup

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –î–æ
use std::sync::Mutex;

pub struct ExpressionEngine {
    expr_cache: Option<Arc<Mutex<ComputeCache<String, Expr>>>>,
}

// –ü–æ—Å–ª–µ
use parking_lot::RwLock;

pub struct ExpressionEngine {
    expr_cache: Option<Arc<RwLock<ComputeCache<Arc<str>, Expr>>>>,
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `parking_lot = "0.12"` –≤ Cargo.toml (5 –º–∏–Ω)
2. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å `Mutex` –Ω–∞ `RwLock` (15 –º–∏–Ω)
3. ‚úÖ –ò–∑–º–µ–Ω–∏—Ç—å –∫–ª—é—á–∏ –∫–µ—à–∞ —Å `String` –Ω–∞ `Arc<str>` (30 –º–∏–Ω)
4. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å `evaluate()` –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è read/write locks (30 –º–∏–Ω)
5. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å benchmark –¥–ª—è concurrent access (1 —á–∞—Å)
6. ‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ—Ç deadlocks (30 –º–∏–Ω)

**–í—Ä–µ–º—è**: 3 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç (–≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –¥–µ—Ç–∞–ª—å)

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚¨ÜÔ∏è Concurrent throughput: 7.5x (—Å 10k ops/sec –¥–æ 75k ops/sec)
- ‚¨áÔ∏è Lock contention: —Å ~80% –¥–æ ~10%
- ‚¨áÔ∏è Allocations: -48 bytes –Ω–∞ cache lookup

---

### P0.3: Context Arc Values ‚≠ê‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: Clone –Ω–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∫–æ–ø–∏—Ä—É–µ—Ç –≤—Å–µ HashMap

**Impact**:
- üî¥ Performance: `clone()` –∑–∞–Ω–∏–º–∞–µ—Ç ~2Œºs –¥–ª—è 100 –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
- üî¥ Memory: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –î–æ
#[derive(Clone)]
pub struct EvaluationContext {
    nodes: HashMap<String, Value>,
    execution_vars: HashMap<String, Value>,
    workflow: Value,
    input: Value,
}

// –ü–æ—Å–ª–µ
use std::sync::Arc;

#[derive(Clone)]
pub struct EvaluationContext {
    nodes: Arc<HashMap<Arc<str>, Value>>,
    execution_vars: Arc<HashMap<Arc<str>, Value>>,
    workflow: Arc<Value>,
    input: Arc<Value>,
    parent: Option<Arc<EvaluationContext>>,
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –û–±–µ—Ä–Ω—É—Ç—å HashMap –≤ Arc (30 –º–∏–Ω)
2. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å String –∫–ª—é—á–∏ –Ω–∞ Arc<str> (30 –º–∏–Ω)
3. ‚úÖ –û–±–µ—Ä–Ω—É—Ç—å workflow/input –≤ Arc (15 –º–∏–Ω)
4. ‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `Arc::make_mut()` –≤ set_* –º–µ—Ç–æ–¥–∞—Ö (COW) (1 —á–∞—Å)
5. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `parent: Option<Arc<Self>>` –¥–ª—è nested scopes (1 —á–∞—Å)
6. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `with_scope()` –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–æ—á–µ—Ä–Ω–∏—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ (1 —á–∞—Å)
7. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å `resolve_variable()` —Å fallback –Ω–∞ parent (30 –º–∏–Ω)
8. ‚úÖ –¢–µ—Å—Ç—ã –¥–ª—è scoping (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 5.5 —á–∞—Å–æ–≤

**Breaking changes**: ‚ùå –ù–µ—Ç (API —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π)

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚¨ÜÔ∏è Clone speed: 40x (—Å ~2Œºs –¥–æ ~50ns)
- ‚¨áÔ∏è Memory: -70% –ø—Ä–∏ –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏
- ‚úÖ Nested scopes —Ä–∞–±–æ—Ç–∞—é—Ç

---

### P0.4: AST String Interning ‚≠ê‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: String –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –¥–ª—è variable names, property names, function names

**Impact**:
- üî¥ Memory: –ö–∞–∂–¥–æ–µ –∏–º—è –∞–ª–ª–æ—Ü–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ
- üî¥ Clone: Deep copy –≤—Å–µ–≥–æ AST –¥–æ—Ä–æ–≥–æ–π

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –î–æ
pub enum Expr {
    Variable(String),
    PropertyAccess { object: Box<Expr>, property: String },
    FunctionCall { name: String, args: Vec<Expr> },
}

// –ü–æ—Å–ª–µ
pub enum Expr {
    Variable(Arc<str>),
    PropertyAccess { object: Arc<Expr>, property: Arc<str> },
    FunctionCall { name: Arc<str>, args: SmallVec<[Expr; 4]> },
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ `String` –Ω–∞ `Arc<str>` –≤ Expr (1 —á–∞—Å)
2. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å `Box<Expr>` –Ω–∞ `Arc<Expr>` (30 –º–∏–Ω)
3. ‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `SmallVec<[Expr; 4]>` –¥–ª—è args (30 –º–∏–Ω)
4. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å Parser –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è Arc (1 —á–∞—Å)
5. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å string interner (optional) (2 —á–∞—Å–∞)
6. ‚úÖ –¢–µ—Å—Ç—ã (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 6 —á–∞—Å–æ–≤

**Breaking changes**: ‚ö†Ô∏è –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (public API –¥–ª—è `Expr` –∏–∑–º–µ–Ω–∏—Ç—Å—è)

**–†–µ—à–µ–Ω–∏–µ**: –î–æ–±–∞–≤–∏—Ç—å deprecation warnings + compatibility layer

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚¨áÔ∏è AST clone: 10x –±—ã—Å—Ç—Ä–µ–µ
- ‚¨áÔ∏è Memory: -50% –¥–ª—è repeated names
- ‚úÖ Sharing subexpressions —Ä–∞–±–æ—Ç–∞–µ—Ç

---

### P0.5: Lexer Zero-Copy ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: `Vec<char>` –∞–ª–ª–æ–∫–∞—Ü–∏—è + O(n) upfront cost

**Impact**:
- üî¥ Memory: Vec allocation (~4n bytes)
- üî¥ Performance: UTF-8 decode –≤—Å–µ–≥–æ input –∑–∞—Ä–∞–Ω–µ–µ

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –î–æ
pub struct Lexer {
    input: Vec<char>,
    position: usize,
}

impl Lexer {
    pub fn new(input: &str) -> Self {
        let chars: Vec<char> = input.chars().collect(); // ‚ùå
        Self { input: chars, position: 0 }
    }
}

// –ü–æ—Å–ª–µ
pub struct Lexer<'a> {
    input: &'a str,
    bytes: &'a [u8],
    position: usize,
}

impl<'a> Lexer<'a> {
    pub fn new(input: &'a str) -> Self {
        Self {
            input,
            bytes: input.as_bytes(),
            position: 0,
        }
    }

    fn current_byte(&self) -> Option<u8> {
        self.bytes.get(self.position).copied()
    }

    // Fast path –¥–ª—è ASCII operators
    fn read_operator(&mut self) -> Option<Token> {
        match self.current_byte()? {
            b'+' => { self.position += 1; Some(Token::Plus) }
            b'-' => { self.position += 1; Some(Token::Minus) }
            // ...
        }
    }

    // Slow path –¥–ª—è Unicode strings
    fn read_string(&mut self) -> ExpressionResult<Token> {
        let start = self.position;
        // ... using chars() only for string content
    }
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å lifetime –ø–∞—Ä–∞–º–µ—Ç—Ä –∫ Lexer (30 –º–∏–Ω)
2. ‚úÖ –ó–∞–º–µ–Ω–∏—Ç—å `Vec<char>` –Ω–∞ `&str` + `&[u8]` (1 —á–∞—Å)
3. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å byte-level parsing –¥–ª—è operators (2 —á–∞—Å–∞)
4. ‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å char iteration —Ç–æ–ª—å–∫–æ –¥–ª—è strings (1 —á–∞—Å)
5. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å position tracking (UTF-8 aware) (1 —á–∞—Å)
6. ‚úÖ –¢–µ—Å—Ç—ã —Å Unicode (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 6.5 —á–∞—Å–æ–≤

**Breaking changes**: ‚ùå –ù–µ—Ç (Lexer –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –º–æ–¥—É–ª—å)

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚¨áÔ∏è Allocations: 0 (–≤–º–µ—Å—Ç–æ Vec allocation)
- ‚¨ÜÔ∏è Speed: 1.5x –±—ã—Å—Ç—Ä–µ–µ
- ‚úÖ Unicode –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞

---

### P0.6: Eval Recursion Limit ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: Stack overflow –Ω–∞ –≥–ª—É–±–æ–∫–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö

**Impact**:
- üî¥ Security: DoS –∞—Ç–∞–∫–∞ –≤–æ–∑–º–æ–∂–Ω–∞
- üî¥ Stability: –ö—Ä–∞—à –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

**–†–µ—à–µ–Ω–∏–µ**:

```rust
pub struct Evaluator {
    builtins: Arc<BuiltinRegistry>,
    max_depth: usize,  // –ù–æ–≤–æ–µ –ø–æ–ª–µ
}

impl Evaluator {
    pub fn eval(&self, expr: &Expr, context: &EvaluationContext) -> ExpressionResult<Value> {
        self.eval_with_depth(expr, context, 0)
    }

    fn eval_with_depth(
        &self,
        expr: &Expr,
        context: &EvaluationContext,
        depth: usize,
    ) -> ExpressionResult<Value> {
        if depth > self.max_depth {
            return Err(NebulaError::expression_eval_error(
                format!("Expression too deeply nested (limit: {})", self.max_depth)
            ));
        }

        match expr {
            Expr::Binary { left, op, right } => {
                let left_val = self.eval_with_depth(left, context, depth + 1)?;
                let right_val = self.eval_with_depth(right, context, depth + 1)?;
                self.eval_binary_op(&left_val, op, &right_val)
            }
            // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –≤–µ—Ç–∫–∏ —Å depth + 1
        }
    }
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `max_depth` field –≤ Evaluator (15 –º–∏–Ω)
2. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `depth` –ø–∞—Ä–∞–º–µ—Ç—Ä –≤ eval (30 –º–∏–Ω)
3. ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ depth > max_depth (15 –º–∏–Ω)
4. ‚úÖ Propagate depth —á–µ—Ä–µ–∑ –≤—Å–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–µ –≤—ã–∑–æ–≤—ã (1 —á–∞—Å)
5. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –≤ EngineConfig (30 –º–∏–Ω)
6. ‚úÖ –¢–µ—Å—Ç—ã —Å –≥–ª—É–±–æ–∫–∏–º–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏ (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 3.5 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚úÖ DoS protected (max depth = 100 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
- ‚úÖ Configurable limit
- ‚úÖ Clear error message

---

### P0.7: Short-circuit Evaluation ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: `&&` –∏ `||` –≤—Å–µ–≥–¥–∞ –≤—ã—á–∏—Å–ª—è—é—Ç –æ–±–∞ –æ–ø–µ—Ä–∞–Ω–¥–∞

**Impact**:
- üî¥ Performance: –õ–∏—à–Ω–∏–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
- üî¥ Correctness: `x != null && x.prop` –º–æ–∂–µ—Ç crash

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –í eval/mod.rs
fn eval_binary_op(&self, left: &Value, op: &BinaryOp, right_expr: &Expr, context: &EvaluationContext) -> ExpressionResult<Value> {
    match op {
        BinaryOp::And => {
            // Short-circuit: –µ—Å–ª–∏ left == false, –Ω–µ –≤—ã—á–∏—Å–ª—è–µ–º right
            if !left.to_boolean() {
                return Ok(Value::boolean(false));
            }
            let right = self.eval(right_expr, context)?;
            Ok(Value::boolean(right.to_boolean()))
        }
        BinaryOp::Or => {
            // Short-circuit: –µ—Å–ª–∏ left == true, –Ω–µ –≤—ã—á–∏—Å–ª—è–µ–º right
            if left.to_boolean() {
                return Ok(Value::boolean(true));
            }
            let right = self.eval(right_expr, context)?;
            Ok(Value::boolean(right.to_boolean()))
        }
        _ => {
            // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –≤—ã—á–∏—Å–ª—è–µ–º –æ–±–∞
            let right = self.eval(right_expr, context)?;
            self.eval_binary_op_values(left, op, &right)
        }
    }
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –ò–∑–º–µ–Ω–∏—Ç—å signature `eval_binary_op` (1 —á–∞—Å)
2. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å short-circuit –¥–ª—è `&&` (30 –º–∏–Ω)
3. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å short-circuit –¥–ª—è `||` (30 –º–∏–Ω)
4. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å –≤—ã–∑–æ–≤—ã –∏–∑ `eval()` (30 –º–∏–Ω)
5. ‚úÖ –¢–µ—Å—Ç—ã (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 3.5 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç (—É–ª—É—á—à–µ–Ω–∏–µ behavior)

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚úÖ `false && expensive()` –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç expensive
- ‚úÖ `true || expensive()` –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç expensive
- ‚úÖ `x != null && x.prop` —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

---

### P0.8: Builtin Regex Caching ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: `Regex::new()` –≤ –∫–∞–∂–¥–æ–º –≤—ã–∑–æ–≤–µ `=~`

**Impact**:
- üî¥ Performance: –ü–∞—Ä—Å–∏–Ω–≥ regex –Ω–∞ –∫–∞–∂–¥–æ–º –≤—ã–∑–æ–≤–µ
- üî¥ Memory: –õ–∏—à–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–∏

**–†–µ—à–µ–Ω–∏–µ**:

```rust
use lru::LruCache;
use std::sync::Mutex;

pub struct Evaluator {
    builtins: Arc<BuiltinRegistry>,
    max_depth: usize,
    regex_cache: Mutex<LruCache<String, Regex>>,  // –ù–æ–≤–æ–µ
}

impl Evaluator {
    fn eval_regex_match(&self, text: &str, pattern: &str) -> ExpressionResult<bool> {
        let mut cache = self.regex_cache.lock().unwrap();

        let regex = cache.get_or_insert(pattern.to_string(), || {
            Regex::new(pattern).map_err(|e| {
                NebulaError::expression_eval_error(format!("Invalid regex: {}", e))
            })
        })?;

        Ok(regex.is_match(text))
    }
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `lru = "0.12"` dependency (5 –º–∏–Ω)
2. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `regex_cache` field –≤ Evaluator (15 –º–∏–Ω)
3. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å `eval_binary_op` –¥–ª—è RegexMatch (30 –º–∏–Ω)
4. ‚úÖ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å cache size (configurable) (30 –º–∏–Ω)
5. ‚úÖ Benchmark (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 2.5 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç

**–ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞**:
- ‚¨ÜÔ∏è Regex match: 10-100x –±—ã—Å—Ç—Ä–µ–µ (–¥–ª—è repeated patterns)
- ‚¨áÔ∏è Allocations: 0 –¥–ª—è cached patterns

---

### P0.9: Parser Recursion Limit ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: Stack overflow –Ω–∞ –≥–ª—É–±–æ–∫–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ

**Impact**:
- üî¥ Security: DoS –∞—Ç–∞–∫–∞
- üî¥ Stability: –ö—Ä–∞—à

**–†–µ—à–µ–Ω–∏–µ**:

```rust
pub struct Parser {
    tokens: Vec<Token>,
    position: usize,
    max_depth: usize,
    current_depth: usize,
}

impl Parser {
    fn parse_expression(&mut self) -> ExpressionResult<Expr> {
        self.current_depth += 1;

        if self.current_depth > self.max_depth {
            return Err(NebulaError::expression_parse_error(
                format!("Expression too deeply nested (limit: {})", self.max_depth)
            ));
        }

        let result = self.parse_conditional();
        self.current_depth -= 1;
        result
    }
}
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å depth tracking (30 –º–∏–Ω)
2. ‚úÖ Check –≤ –∫–∞–∂–¥–æ–π —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ (1 —á–∞—Å)
3. ‚úÖ –¢–µ—Å—Ç—ã (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 2.5 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç

---

### P0.10: lib.rs API Surface ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: –ü—É–±–ª–∏—á–Ω—ã–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–æ–¥—É–ª–∏ (lexer, parser, eval, builtins)

**Impact**:
- üî¥ API: –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –±–µ–∑ breaking changes
- üî¥ Complexity: –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —ç–∫—Å–ø–æ—Ä—Ç–æ–≤

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// lib.rs

// –ü—É–±–ª–∏—á–Ω—ã–µ –º–æ–¥—É–ª–∏ (stable API)
pub mod context;
pub mod engine;
pub mod error_formatter;
pub mod maybe;
pub mod template;

// –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–æ–¥—É–ª–∏ (–¥–µ—Ç–∞–ª–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏)
mod builtins;
mod core;
mod eval;
mod lexer;
mod parser;

// –≠–∫—Å–ø–æ—Ä—Ç —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–≥–æ –∏–∑ core
pub use core::error::{ExpressionErrorExt, ExpressionResult};
// –£–±—Ä–∞—Ç—å: pub use core::ast::{BinaryOp, Expr};
// –£–±—Ä–∞—Ç—å: pub use core::token::Token;
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –°–¥–µ–ª–∞—Ç—å –º–æ–¥—É–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–º–∏ (15 –º–∏–Ω)
2. ‚úÖ –£–±—Ä–∞—Ç—å –ª–∏—à–Ω–∏–µ re-exports (15 –º–∏–Ω)
3. ‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –ø—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç (30 –º–∏–Ω)
4. ‚úÖ –û–±–Ω–æ–≤–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é (30 –º–∏–Ω)

**–í—Ä–µ–º—è**: 1.5 —á–∞—Å–∞

**Breaking changes**: ‚ö†Ô∏è –î–∞, –Ω–æ –º–∏–Ω–æ—Ä–Ω—ã–π (—Ä–µ–¥–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)

**–†–µ—à–µ–Ω–∏–µ**: Deprecation period + migration guide

---

### P0.11: Feature Flags ‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: –í—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤–∫–ª—é—á–µ–Ω—ã –≤—Å–µ–≥–¥–∞ (regex, chrono, etc)

**Impact**:
- üü° Compilation time: –õ–∏—à–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
- üü° Binary size: –ë–æ–ª—å—à–µ —á–µ–º –Ω—É–∂–Ω–æ

**–†–µ—à–µ–Ω–∏–µ**:

```toml
# Cargo.toml
[features]
default = []
cache = ["nebula-memory/cache"]
datetime = ["dep:chrono"]
regex-support = ["dep:regex"]
metrics = []
parallel = ["dep:rayon"]

[dependencies]
regex = { version = "1.11", optional = true }
chrono = { workspace = true, optional = true }
rayon = { version = "1.8", optional = true }
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å features –≤ Cargo.toml (30 –º–∏–Ω)
2. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å `#[cfg(feature = "...")]` (1 —á–∞—Å)
3. ‚úÖ Fallback implementations (1 —á–∞—Å)
4. ‚úÖ CI –¥–ª—è —Ä–∞–∑–Ω—ã—Ö feature combinations (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 3.5 —á–∞—Å–∞

**Breaking changes**: ‚ùå –ù–µ—Ç (default = –≤—Å–µ –≤–∫–ª—é—á–µ–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)

---

### P0.12: Builtin Type Safety ‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç compile-time –ø—Ä–æ–≤–µ—Ä–æ–∫ —Ç–∏–ø–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π

**Impact**:
- üü° Safety: –õ–µ–≥–∫–æ –æ—à–∏–±–∏—Ç—å—Å—è –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
- üü° DX: –ü–ª–æ—Ö–∏–µ error messages

**–†–µ—à–µ–Ω–∏–µ**:

```rust
// –ù–æ–≤—ã–π typed API
pub trait TypedBuiltin {
    fn name(&self) -> &'static str;
    fn call(&self, args: &[Value]) -> ExpressionResult<Value>;
}

// Macro –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è
macro_rules! builtin {
    ($name:expr, |$($arg:ident: $ty:ty),*| -> $ret:ty $body:block) => {
        struct BuiltinImpl;
        impl TypedBuiltin for BuiltinImpl {
            fn name(&self) -> &'static str { $name }
            fn call(&self, args: &[Value]) -> ExpressionResult<Value> {
                // Type checking + extraction
                $(let $arg: $ty = args[index].try_into()?;)*
                let result: $ret = $body;
                Ok(result.into())
            }
        }
    };
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
builtin!("uppercase", |s: String| -> String {
    s.to_uppercase()
});
```

**–®–∞–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

1. ‚úÖ –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å TypedBuiltin trait (1 —á–∞—Å)
2. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å macro (2 —á–∞—Å–∞)
3. ‚úÖ –ú–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ (3 —á–∞—Å–∞)
4. ‚úÖ –¢–µ—Å—Ç—ã (1 —á–∞—Å)

**–í—Ä–µ–º—è**: 7 —á–∞—Å–æ–≤

**Breaking changes**: ‚ùå –ù–µ—Ç (–≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –¥–µ—Ç–∞–ª—å)

---

## –ò—Ç–æ–≥–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞ P0

| # | –ü—Ä–æ–±–ª–µ–º–∞ | –í—Ä–µ–º—è | Impact | Breaking | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç |
|---|----------|-------|--------|----------|-----------|
| 1 | Template Zero-Copy | 4h | üî¥üî¥üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| 2 | Engine RwLock | 3h | üî¥üî¥üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| 3 | Context Arc | 5.5h | üî¥üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê‚≠ê |
| 4 | AST Interning | 6h | üî¥üî¥üî¥üî¥ | ‚ö†Ô∏è | ‚≠ê‚≠ê‚≠ê‚≠ê |
| 5 | Lexer Zero-Copy | 6.5h | üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê |
| 6 | Eval Recursion | 3.5h | üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê |
| 7 | Short-circuit | 3.5h | üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê |
| 8 | Regex Cache | 2.5h | üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê |
| 9 | Parser Recursion | 2.5h | üî¥üî¥üî¥ | ‚ùå | ‚≠ê‚≠ê‚≠ê |
| 10 | API Surface | 1.5h | üî¥üî¥ | ‚ö†Ô∏è | ‚≠ê‚≠ê‚≠ê |
| 11 | Feature Flags | 3.5h | üü°üü° | ‚ùå | ‚≠ê‚≠ê |
| 12 | Type Safety | 7h | üü°üü° | ‚ùå | ‚≠ê‚≠ê |

**–ò—Ç–æ–≥–æ**: ~49 —á–∞—Å–æ–≤ (~6 —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π)

---

## –í–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã (P1)

> üéØ **–¶–µ–ª—å**: –†–µ—à–∏—Ç—å –∑–∞ **1 –º–µ—Å—è—Ü**
>
> üí∞ **ROI**: –í—ã—Å–æ–∫–∏–π (—Å—Ä–µ–¥–Ω—è—è –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å + —Å—Ä–µ–¥–Ω—è—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å)

### P1.1: Token Lifetime Parameters ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: String –≤ Token

**–†–µ—à–µ–Ω–∏–µ**:
```rust
pub enum Token<'a> {
    Identifier(&'a str),
    String(Cow<'a, str>),  // Borrowed –¥–ª—è literals, Owned –¥–ª—è escaped
    Variable(&'a str),
}
```

**–í—Ä–µ–º—è**: 4 —á–∞—Å–∞

---

### P1.2: Error Context ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç span/position –≤ –æ—à–∏–±–∫–∞—Ö

**–†–µ—à–µ–Ω–∏–µ**:
```rust
pub struct ExpressionError {
    message: Cow<'static, str>,
    span: Option<Span>,
    kind: ErrorKind,
}
```

**–í—Ä–µ–º—è**: 5 —á–∞—Å–æ–≤

---

### P1.3: Iterator-based Builtins ‚≠ê‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: –ê–ª–ª–æ–∫–∞—Ü–∏–∏ –≤ array/object —Ñ—É–Ω–∫—Ü–∏—è—Ö

**–†–µ—à–µ–Ω–∏–µ**:
```rust
// –í–º–µ—Å—Ç–æ
pub fn keys(obj: &Value) -> ExpressionResult<Value> {
    let keys: Vec<Value> = obj.as_object()?.keys().map(Value::text).collect();
    Ok(Value::Array(keys))
}

// –î–µ–ª–∞–µ–º
pub fn keys(obj: &Value) -> ExpressionResult<impl Iterator<Item = &str>> {
    obj.as_object()?.keys()
}
```

**–í—Ä–µ–º—è**: 8 —á–∞—Å–æ–≤

---

### P1.4: Maybe Lazy Parsing ‚≠ê‚≠ê

**–ü—Ä–æ–±–ª–µ–º–∞**: MaybeExpression –≤—Å–µ–≥–¥–∞ —Ö—Ä–∞–Ω–∏—Ç String

**–†–µ—à–µ–Ω–∏–µ**:
```rust
pub enum MaybeExpression<'a, T> {
    Value(T),
    Expression {
        source: Cow<'a, str>,
        cached_ast: OnceCell<Expr>,
    },
}
```

**–í—Ä–µ–º—è**: 3 —á–∞—Å–∞

---

### P1.5-P1.23: –û—Å—Ç–∞–ª—å–Ω—ã–µ (–¥–µ—Ç–∞–ª–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å–µ–∫—Ü–∏–∏)

---

## –ü–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### Week 1: Foundation (P0.1-P0.4)

**–¶–µ–ª—å**: Zero-copy + Arc –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

**–î–µ–Ω—å 1-2**:
- ‚úÖ P0.1: Template Zero-Copy (4h)
- ‚úÖ P0.2: Engine RwLock (3h)

**–î–µ–Ω—å 3-4**:
- ‚úÖ P0.3: Context Arc (5.5h)
- ‚úÖ P0.4: AST Interning (6h)

**–î–µ–Ω—å 5**:
- ‚úÖ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
- ‚úÖ Benchmarks
- ‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

**Deliverables**:
- üéØ 70% –º–µ–Ω—å—à–µ allocations
- üéØ 5x –±—ã—Å—Ç—Ä–µ–µ clone()
- üéØ 7.5x concurrent throughput

---

### Week 2: Safety + Performance (P0.5-P0.9)

**–¶–µ–ª—å**: –ó–∞—â–∏—Ç–∞ –æ—Ç DoS + –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ eval

**–î–µ–Ω—å 1**:
- ‚úÖ P0.5: Lexer Zero-Copy (6.5h)

**–î–µ–Ω—å 2**:
- ‚úÖ P0.6: Eval Recursion Limit (3.5h)
- ‚úÖ P0.7: Short-circuit (3.5h)

**–î–µ–Ω—å 3**:
- ‚úÖ P0.8: Regex Caching (2.5h)
- ‚úÖ P0.9: Parser Recursion (2.5h)

**–î–µ–Ω—å 4-5**:
- ‚úÖ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- ‚úÖ Fuzzing
- ‚úÖ Performance regression tests

**Deliverables**:
- üéØ DoS protected
- üéØ 10x faster regex
- üéØ 1.5x faster lexing

---

### Week 3: API Cleanup (P0.10-P0.12)

**–¶–µ–ª—å**: –°—Ç–∞–±–∏–ª—å–Ω—ã–π –ø—É–±–ª–∏—á–Ω—ã–π API

**–î–µ–Ω—å 1**:
- ‚úÖ P0.10: API Surface (1.5h)
- ‚úÖ P0.11: Feature Flags (3.5h)

**–î–µ–Ω—å 2-3**:
- ‚úÖ P0.12: Builtin Type Safety (7h)

**–î–µ–Ω—å 4-5**:
- ‚úÖ Migration guide
- ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ examples
- ‚úÖ Documentation review

**Deliverables**:
- üéØ Clean API boundary
- üéØ Optional dependencies
- üéØ Type-safe builtins

---

### Week 4: P1 Tasks

**–¶–µ–ª—å**: –í–∞–∂–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

- ‚úÖ P1.1: Token lifetimes
- ‚úÖ P1.2: Error context
- ‚úÖ P1.3: Iterator builtins
- ‚úÖ P1.4: Maybe lazy parsing

---

## –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

### Performance

| –ú–µ—Ç—Ä–∏–∫–∞ | –î–æ | –ü–æ—Å–ª–µ P0 | –£–ª—É—á—à–µ–Ω–∏–µ |
|---------|-----|----------|-----------|
| Template parse | 10Œºs | 2Œºs | **5x** |
| Expression eval | 50Œºs | 15Œºs | **3.3x** |
| Context clone | 2Œºs | 50ns | **40x** |
| Concurrent ops/sec | 10k | 75k | **7.5x** |
| Regex match (cached) | 10Œºs | 0.1Œºs | **100x** |

### Memory

| –ú–µ—Ç—Ä–∏–∫–∞ | –î–æ | –ü–æ—Å–ª–µ P0 | –£–ª—É—á—à–µ–Ω–∏–µ |
|---------|-----|----------|-----------|
| Allocations/eval | ~15 | ~3 | **5x** |
| Template memory | 500 bytes | 150 bytes | **3.3x** |
| AST clone | Deep copy | Ref count | **‚àû** |
| Context clone | Full copy | Ref count | **‚àû** |

### Safety

- ‚úÖ DoS protected (recursion limits)
- ‚úÖ No stack overflow
- ‚úÖ Proper error messages with context
- ‚úÖ Type-safe builtins

### API Quality

- ‚úÖ Clean public API (no internal leaks)
- ‚úÖ Feature flags –¥–ª—è optional deps
- ‚úÖ Zero breaking changes (–¥–ª—è —Ç–µ–∫—É—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)
- ‚úÖ Comprehensive documentation

---

## –ß–µ–∫–ª–∏—Å—Ç –¥–ª—è –∫–∞–∂–¥–æ–π –∑–∞–¥–∞—á–∏

### Before Implementation

- [ ] –°–æ–∑–¥–∞—Ç—å feature branch
- [ ] –ù–∞–ø–∏—Å–∞—Ç—å failing test
- [ ] –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å expected behavior

### During Implementation

- [ ] –°–ª–µ–¥–æ–≤–∞—Ç—å code style
- [ ] –î–æ–±–∞–≤–∏—Ç—å inline docs
- [ ] –û–±–Ω–æ–≤–∏—Ç—å –ø—É–±–ª–∏—á–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é

### After Implementation

- [ ] –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
- [ ] Benchmarks –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç —É–ª—É—á—à–µ–Ω–∏–µ
- [ ] No clippy warnings
- [ ] –û–±–Ω–æ–≤–∏—Ç—å CHANGELOG.md
- [ ] Code review
- [ ] Merge to main

---

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–≠—Ç–æ—Ç roadmap –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:

1. **–ë—ã—Å—Ç—Ä—ã–µ –ø–æ–±–µ–¥—ã** (Week 1-2): –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
2. **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å** (Week 3): –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø—É–±–ª–∏—á–Ω—ã–π API
3. **–ö–∞—á–µ—Å—Ç–≤–æ** (Week 4+): –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

**–û–±—â–µ–µ –≤—Ä–µ–º—è**: ~6 –Ω–µ–¥–µ–ª—å –¥–ª—è P0-P1

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç**:
- ‚¨ÜÔ∏è 5-10x –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- ‚¨áÔ∏è 70-80% allocations
- ‚úÖ Production-ready API
- ‚úÖ DoS protected

---

**–ê–≤—Ç–æ—Ä**: AI Analysis
**–î–∞—Ç–∞**: 2025-01-08
**–í–µ—Ä—Å–∏—è**: 1.0

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/crates/nebula-log/examples/file_logging.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crates/nebula-log/examples/file_logging.rs" />
              <option name="originalContent" value="#[cfg(feature = &quot;file&quot;)]&#10;use nebula_log::{Config, Format};&#10;#[cfg(feature = &quot;file&quot;)]&#10;use nebula_log::config::{Rolling, WriterConfig};&#10;&#10;fn main() -&gt; nebula_log::Result&lt;()&gt; {&#10;    #[cfg(feature = &quot;file&quot;)]&#10;    {&#10;        let mut config = Config::default();&#10;        config.format = Format::Json;&#10;        config.writer = WriterConfig::File {&#10;            path: &quot;logs/app.log&quot;.into(),&#10;            rolling: Some(Rolling::Daily),&#10;            non_blocking: true,&#10;        };&#10;&#10;        let _guard = nebula_log::init_with(config)?;&#10;&#10;        tracing::info!(&quot;Logging to file with daily rotation&quot;);&#10;&#10;        // Simulate application&#10;        for i in 0..10 {&#10;            tracing::info!(iteration = i, &quot;Processing batch&quot;);&#10;            std::thread::sleep(std::time::Duration::from_millis(100));&#10;        }&#10;    }&#10;&#10;    #[cfg(not(feature = &quot;file&quot;))]&#10;    println!(&quot;File logging requires the 'file' feature&quot;);&#10;&#10;    Ok(())&#10;}" />
              <option name="updatedContent" value="#[cfg(feature = &quot;file&quot;)]&#10;use nebula_log::{Config, Format, Rolling, WriterConfig};&#10;&#10;fn main() -&gt; nebula_log::Result&lt;()&gt; {&#10;    #[cfg(feature = &quot;file&quot;)]&#10;    {&#10;        let mut config = Config::default();&#10;        config.format = Format::Json;&#10;        config.writer = WriterConfig::File {&#10;            path: &quot;logs/app.log&quot;.into(),&#10;            rolling: Some(Rolling::Daily),&#10;            non_blocking: true,&#10;        };&#10;&#10;        let _guard = nebula_log::init_with(config)?;&#10;&#10;        tracing::info!(&quot;Logging to file with daily rotation&quot;);&#10;&#10;        // Simulate application&#10;        for i in 0..10 {&#10;            tracing::info!(iteration = i, &quot;Processing batch&quot;);&#10;            std::thread::sleep(std::time::Duration::from_millis(100));&#10;        }&#10;    }&#10;&#10;    #[cfg(not(feature = &quot;file&quot;))]&#10;    println!(&quot;File logging requires the 'file' feature&quot;);&#10;&#10;    Ok(())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crates/nebula-log/src/config.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crates/nebula-log/src/config.rs" />
              <option name="originalContent" value="//! Configuration types and builders&#10;&#10;use serde::{Deserialize, Serialize};&#10;use std::path::PathBuf;&#10;&#10;/// Logging configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;#[serde(default)]&#10;pub struct Config {&#10;    /// Log level filter (e.g., &quot;info&quot;, &quot;debug,hyper=warn&quot;)&#10;    pub level: String,&#10;&#10;    /// Output format&#10;    pub format: Format,&#10;&#10;    /// Output writer configuration&#10;    pub writer: WriterConfig,&#10;&#10;    /// Display configuration&#10;    pub display: DisplayConfig,&#10;&#10;    /// Global fields to include in all events&#10;    pub fields: Fields,&#10;&#10;    /// Enable runtime reload capability&#10;    pub reloadable: bool,&#10;&#10;    /// Telemetry configuration&#10;    #[cfg(feature = &quot;telemetry&quot;)]&#10;    pub telemetry: Option&lt;TelemetryConfig&gt;,&#10;}&#10;&#10;/// Output format&#10;#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]&#10;#[serde(rename_all = &quot;lowercase&quot;)]&#10;pub enum Format {&#10;    /// Human-readable with colors and indentation&#10;    Pretty,&#10;    /// Compact single-line output&#10;    Compact,&#10;    /// Structured JSON output&#10;    Json,&#10;    /// Logfmt format (key=value pairs)&#10;    Logfmt,&#10;}&#10;&#10;/// Log level&#10;#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]&#10;#[serde(rename_all = &quot;lowercase&quot;)]&#10;pub enum Level {&#10;    /// Trace level&#10;    Trace,&#10;    /// Debug level&#10;    Debug,&#10;    /// Info level&#10;    Info,&#10;    /// Warn level&#10;    Warn,&#10;    /// Error level&#10;    Error,&#10;}&#10;&#10;impl std::fmt::Display for Level {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        match self {&#10;            Level::Trace =&gt; write!(f, &quot;trace&quot;),&#10;            Level::Debug =&gt; write!(f, &quot;debug&quot;),&#10;            Level::Info =&gt; write!(f, &quot;info&quot;),&#10;            Level::Warn =&gt; write!(f, &quot;warn&quot;),&#10;            Level::Error =&gt; write!(f, &quot;error&quot;),&#10;        }&#10;    }&#10;}&#10;&#10;/// Writer configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;#[serde(tag = &quot;type&quot;, rename_all = &quot;lowercase&quot;)]&#10;pub enum WriterConfig {&#10;    /// Write to stderr&#10;    Stderr,&#10;    /// Write to stdout&#10;    Stdout,&#10;    /// Write to file&#10;    #[cfg(feature = &quot;file&quot;)]&#10;    File {&#10;        path: PathBuf,&#10;        #[serde(default)]&#10;        rolling: Option&lt;Rolling&gt;,&#10;        #[serde(default = &quot;default_true&quot;)]&#10;        non_blocking: bool,&#10;    },&#10;    /// Write to multiple destinations&#10;    Multi(Vec&lt;WriterConfig&gt;),&#10;}&#10;&#10;/// File rolling strategy&#10;#[derive(Debug, Clone, Copy, Serialize, Deserialize)]&#10;#[serde(rename_all = &quot;lowercase&quot;)]&#10;pub enum Rolling {&#10;    /// Never roll files&#10;    Never,&#10;    /// Roll hourly&#10;    Hourly,&#10;    /// Roll daily&#10;    Daily,&#10;    /// Roll by size in MB (not yet implemented)&#10;    Size(u64),&#10;}&#10;&#10;/// Display configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;#[serde(default)]&#10;pub struct DisplayConfig {&#10;    /// Show timestamps&#10;    pub time: bool,&#10;    /// Custom time format (strftime)&#10;    pub time_format: Option&lt;String&gt;,&#10;    /// Show source location (file:line)&#10;    pub source: bool,&#10;    /// Show target module&#10;    pub target: bool,&#10;    /// Show thread IDs&#10;    pub thread_ids: bool,&#10;    /// Show thread names&#10;    pub thread_names: bool,&#10;    /// Use ANSI colors&#10;    pub colors: bool,&#10;    /// Show span list in JSON&#10;    pub span_list: bool,&#10;    /// Flatten JSON events&#10;    pub flatten: bool,&#10;}&#10;&#10;/// Global fields configuration&#10;#[derive(Debug, Clone, Default, Serialize, Deserialize)]&#10;pub struct Fields {&#10;    /// Service name&#10;    pub service: Option&lt;String&gt;,&#10;    /// Environment (dev/staging/prod)&#10;    pub env: Option&lt;String&gt;,&#10;    /// Version&#10;    pub version: Option&lt;String&gt;,&#10;    /// Instance ID&#10;    pub instance: Option&lt;String&gt;,&#10;    /// Region&#10;    pub region: Option&lt;String&gt;,&#10;    /// Custom fields&#10;    #[serde(flatten)]&#10;    pub custom: std::collections::BTreeMap&lt;String, serde_json::Value&gt;,&#10;}&#10;&#10;#[cfg(feature = &quot;telemetry&quot;)]&#10;/// Telemetry configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;pub struct TelemetryConfig {&#10;    /// OpenTelemetry endpoint&#10;    pub otlp_endpoint: Option&lt;String&gt;,&#10;    /// Service name for traces&#10;    pub service_name: String,&#10;    /// Sampling rate (0.0-1.0)&#10;    pub sampling_rate: f64,&#10;}&#10;&#10;// ============================================================================&#10;// Implementations&#10;// ============================================================================&#10;&#10;impl Default for Config {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            level: &quot;info&quot;.to_string(),&#10;            format: Format::Compact,&#10;            writer: WriterConfig::Stderr,&#10;            display: DisplayConfig::default(),&#10;            fields: Fields::default(),&#10;            reloadable: false,&#10;            #[cfg(feature = &quot;telemetry&quot;)]&#10;            telemetry: None,&#10;        }&#10;    }&#10;}&#10;&#10;impl Config {&#10;    /// Create configuration from environment variables&#10;    pub fn from_env() -&gt; Self {&#10;        let mut config = Self::default();&#10;&#10;        // Parse NEBULA_LOG or RUST_LOG&#10;        if let Ok(level) = std::env::var(&quot;NEBULA_LOG&quot;) {&#10;            config.level = level;&#10;        } else if let Ok(level) = std::env::var(&quot;RUST_LOG&quot;) {&#10;            config.level = level;&#10;        }&#10;&#10;        // Parse format&#10;        if let Ok(format) = std::env::var(&quot;NEBULA_LOG_FORMAT&quot;) {&#10;            config.format = match format.to_lowercase().as_str() {&#10;                &quot;pretty&quot; =&gt; Format::Pretty,&#10;                &quot;json&quot; =&gt; Format::Json,&#10;                &quot;logfmt&quot; =&gt; Format::Logfmt,&#10;                _ =&gt; Format::Compact,&#10;            };&#10;        }&#10;&#10;        // Parse display options&#10;        config.display.parse_env();&#10;&#10;        // Parse fields from env&#10;        config.fields = Fields::from_env();&#10;&#10;        config&#10;    }&#10;&#10;    /// Development configuration (pretty, debug level)&#10;    pub fn development() -&gt; Self {&#10;        Self {&#10;            level: &quot;debug&quot;.to_string(),&#10;            format: Format::Pretty,&#10;            display: DisplayConfig {&#10;                colors: true,&#10;                source: true,&#10;                ..DisplayConfig::default()&#10;            },&#10;            ..Self::default()&#10;        }&#10;    }&#10;&#10;    /// Production configuration (JSON, info level)&#10;    pub fn production() -&gt; Self {&#10;        Self {&#10;            level: &quot;info&quot;.to_string(),&#10;            format: Format::Json,&#10;            display: DisplayConfig {&#10;                colors: false,&#10;                source: false,&#10;                flatten: true,&#10;                ..DisplayConfig::default()&#10;            },&#10;            ..Self::default()&#10;        }&#10;    }&#10;&#10;    /// Test configuration (captures output)&#10;    #[cfg(test)]&#10;    pub fn test() -&gt; Self {&#10;        Self {&#10;            level: &quot;trace&quot;.to_string(),&#10;            format: Format::Compact,&#10;            display: DisplayConfig {&#10;                colors: false,&#10;                time: false,&#10;                ..DisplayConfig::default()&#10;            },&#10;            ..Self::default()&#10;        }&#10;    }&#10;}&#10;&#10;impl Default for DisplayConfig {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            time: true,&#10;            time_format: None,&#10;            source: cfg!(debug_assertions),&#10;            target: true,&#10;            thread_ids: false,&#10;            thread_names: false,&#10;            colors: cfg!(feature = &quot;ansi&quot;) &amp;&amp; std::io::IsTerminal::is_terminal(&amp;std::io::stderr()),&#10;            span_list: true,&#10;            flatten: true,&#10;        }&#10;    }&#10;}&#10;&#10;impl DisplayConfig {&#10;    fn parse_env(&amp;mut self) {&#10;        if let Ok(v) = std::env::var(&quot;NEBULA_LOG_TIME&quot;) {&#10;            self.time = v != &quot;0&quot; &amp;&amp; v != &quot;false&quot;;&#10;        }&#10;        if let Ok(v) = std::env::var(&quot;NEBULA_LOG_SOURCE&quot;) {&#10;            self.source = v != &quot;0&quot; &amp;&amp; v != &quot;false&quot;;&#10;        }&#10;        if let Ok(v) = std::env::var(&quot;NEBULA_LOG_COLORS&quot;) {&#10;            self.colors = v != &quot;0&quot; &amp;&amp; v != &quot;false&quot;;&#10;        }&#10;    }&#10;}&#10;&#10;impl Fields {&#10;    /// Create fields from environment variables&#10;    pub fn from_env() -&gt; Self {&#10;        Self {&#10;            service: std::env::var(&quot;NEBULA_SERVICE&quot;).ok(),&#10;            env: std::env::var(&quot;NEBULA_ENV&quot;).ok(),&#10;            version: std::env::var(&quot;NEBULA_VERSION&quot;).ok()&#10;                .or_else(|| option_env!(&quot;CARGO_PKG_VERSION&quot;).map(String::from)),&#10;            instance: std::env::var(&quot;NEBULA_INSTANCE&quot;).ok(),&#10;            region: std::env::var(&quot;NEBULA_REGION&quot;).ok(),&#10;            custom: Default::default(),&#10;        }&#10;    }&#10;&#10;    /// Check if fields are empty&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.service.is_none()&#10;            &amp;&amp; self.env.is_none()&#10;            &amp;&amp; self.version.is_none()&#10;            &amp;&amp; self.instance.is_none()&#10;            &amp;&amp; self.region.is_none()&#10;            &amp;&amp; self.custom.is_empty()&#10;    }&#10;}&#10;&#10;impl Default for WriterConfig {&#10;    fn default() -&gt; Self {&#10;        Self::Stderr&#10;    }&#10;}&#10;&#10;fn default_true() -&gt; bool {&#10;    true&#10;}" />
              <option name="updatedContent" value="//! Configuration types and builders&#10;&#10;use serde::{Deserialize, Serialize};&#10;&#10;/// Logging configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;#[serde(default)]&#10;pub struct Config {&#10;    /// Log level filter (e.g., &quot;info&quot;, &quot;debug,hyper=warn&quot;)&#10;    pub level: String,&#10;&#10;    /// Output format&#10;    pub format: Format,&#10;&#10;    /// Output writer configuration&#10;    pub writer: WriterConfig,&#10;&#10;    /// Display configuration&#10;    pub display: DisplayConfig,&#10;&#10;    /// Global fields to include in all events&#10;    pub fields: Fields,&#10;&#10;    /// Enable runtime reload capability&#10;    pub reloadable: bool,&#10;&#10;    /// Telemetry configuration&#10;    #[cfg(feature = &quot;telemetry&quot;)]&#10;    pub telemetry: Option&lt;TelemetryConfig&gt;,&#10;}&#10;&#10;/// Output format&#10;#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]&#10;#[serde(rename_all = &quot;lowercase&quot;)]&#10;pub enum Format {&#10;    /// Human-readable with colors and indentation&#10;    Pretty,&#10;    /// Compact single-line output&#10;    Compact,&#10;    /// Structured JSON output&#10;    Json,&#10;    /// Logfmt format (key=value pairs)&#10;    Logfmt,&#10;}&#10;&#10;/// Log level&#10;#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]&#10;#[serde(rename_all = &quot;lowercase&quot;)]&#10;pub enum Level {&#10;    /// Trace level&#10;    Trace,&#10;    /// Debug level&#10;    Debug,&#10;    /// Info level&#10;    Info,&#10;    /// Warn level&#10;    Warn,&#10;    /// Error level&#10;    Error,&#10;}&#10;&#10;impl std::fmt::Display for Level {&#10;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {&#10;        match self {&#10;            Level::Trace =&gt; write!(f, &quot;trace&quot;),&#10;            Level::Debug =&gt; write!(f, &quot;debug&quot;),&#10;            Level::Info =&gt; write!(f, &quot;info&quot;),&#10;            Level::Warn =&gt; write!(f, &quot;warn&quot;),&#10;            Level::Error =&gt; write!(f, &quot;error&quot;),&#10;        }&#10;    }&#10;}&#10;&#10;/// Writer configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;#[serde(tag = &quot;type&quot;, rename_all = &quot;lowercase&quot;)]&#10;pub enum WriterConfig {&#10;    /// Write to stderr&#10;    Stderr,&#10;    /// Write to stdout&#10;    Stdout,&#10;    /// Write to file&#10;    #[cfg(feature = &quot;file&quot;)]&#10;    File {&#10;        path: std::path::PathBuf,&#10;        #[serde(default)]&#10;        rolling: Option&lt;Rolling&gt;,&#10;        #[serde(default = &quot;default_true&quot;)]&#10;        non_blocking: bool,&#10;    },&#10;    /// Write to multiple destinations&#10;    Multi(Vec&lt;WriterConfig&gt;),&#10;}&#10;&#10;/// File rolling strategy&#10;#[derive(Debug, Clone, Copy, Serialize, Deserialize)]&#10;#[serde(rename_all = &quot;lowercase&quot;)]&#10;pub enum Rolling {&#10;    /// Never roll files&#10;    Never,&#10;    /// Roll hourly&#10;    Hourly,&#10;    /// Roll daily&#10;    Daily,&#10;    /// Roll by size in MB (not yet implemented)&#10;    Size(u64),&#10;}&#10;&#10;/// Display configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;#[serde(default)]&#10;pub struct DisplayConfig {&#10;    /// Show timestamps&#10;    pub time: bool,&#10;    /// Custom time format (strftime)&#10;    pub time_format: Option&lt;String&gt;,&#10;    /// Show source location (file:line)&#10;    pub source: bool,&#10;    /// Show target module&#10;    pub target: bool,&#10;    /// Show thread IDs&#10;    pub thread_ids: bool,&#10;    /// Show thread names&#10;    pub thread_names: bool,&#10;    /// Use ANSI colors&#10;    pub colors: bool,&#10;    /// Show span list in JSON&#10;    pub span_list: bool,&#10;    /// Flatten JSON events&#10;    pub flatten: bool,&#10;}&#10;&#10;/// Global fields configuration&#10;#[derive(Debug, Clone, Default, Serialize, Deserialize)]&#10;pub struct Fields {&#10;    /// Service name&#10;    pub service: Option&lt;String&gt;,&#10;    /// Environment (dev/staging/prod)&#10;    pub env: Option&lt;String&gt;,&#10;    /// Version&#10;    pub version: Option&lt;String&gt;,&#10;    /// Instance ID&#10;    pub instance: Option&lt;String&gt;,&#10;    /// Region&#10;    pub region: Option&lt;String&gt;,&#10;    /// Custom fields&#10;    #[serde(flatten)]&#10;    pub custom: std::collections::BTreeMap&lt;String, serde_json::Value&gt;,&#10;}&#10;&#10;#[cfg(feature = &quot;telemetry&quot;)]&#10;/// Telemetry configuration&#10;#[derive(Debug, Clone, Serialize, Deserialize)]&#10;pub struct TelemetryConfig {&#10;    /// OpenTelemetry endpoint&#10;    pub otlp_endpoint: Option&lt;String&gt;,&#10;    /// Service name for traces&#10;    pub service_name: String,&#10;    /// Sampling rate (0.0-1.0)&#10;    pub sampling_rate: f64,&#10;}&#10;&#10;// ============================================================================&#10;// Implementations&#10;// ============================================================================&#10;&#10;impl Default for Config {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            level: &quot;info&quot;.to_string(),&#10;            format: Format::Compact,&#10;            writer: WriterConfig::Stderr,&#10;            display: DisplayConfig::default(),&#10;            fields: Fields::default(),&#10;            reloadable: false,&#10;            #[cfg(feature = &quot;telemetry&quot;)]&#10;            telemetry: None,&#10;        }&#10;    }&#10;}&#10;&#10;impl Config {&#10;    /// Create configuration from environment variables&#10;    pub fn from_env() -&gt; Self {&#10;        let mut config = Self::default();&#10;&#10;        // Parse NEBULA_LOG or RUST_LOG&#10;        if let Ok(level) = std::env::var(&quot;NEBULA_LOG&quot;) {&#10;            config.level = level;&#10;        } else if let Ok(level) = std::env::var(&quot;RUST_LOG&quot;) {&#10;            config.level = level;&#10;        }&#10;&#10;        // Parse format&#10;        if let Ok(format) = std::env::var(&quot;NEBULA_LOG_FORMAT&quot;) {&#10;            config.format = match format.to_lowercase().as_str() {&#10;                &quot;pretty&quot; =&gt; Format::Pretty,&#10;                &quot;json&quot; =&gt; Format::Json,&#10;                &quot;logfmt&quot; =&gt; Format::Logfmt,&#10;                _ =&gt; Format::Compact,&#10;            };&#10;        }&#10;&#10;        // Parse display options&#10;        config.display.parse_env();&#10;&#10;        // Parse fields from env&#10;        config.fields = Fields::from_env();&#10;&#10;        config&#10;    }&#10;&#10;    /// Development configuration (pretty, debug level)&#10;    pub fn development() -&gt; Self {&#10;        Self {&#10;            level: &quot;debug&quot;.to_string(),&#10;            format: Format::Pretty,&#10;            display: DisplayConfig {&#10;                colors: true,&#10;                source: true,&#10;                ..DisplayConfig::default()&#10;            },&#10;            ..Self::default()&#10;        }&#10;    }&#10;&#10;    /// Production configuration (JSON, info level)&#10;    pub fn production() -&gt; Self {&#10;        Self {&#10;            level: &quot;info&quot;.to_string(),&#10;            format: Format::Json,&#10;            display: DisplayConfig {&#10;                colors: false,&#10;                source: false,&#10;                flatten: true,&#10;                ..DisplayConfig::default()&#10;            },&#10;            ..Self::default()&#10;        }&#10;    }&#10;&#10;    /// Test configuration (captures output)&#10;    #[cfg(test)]&#10;    pub fn test() -&gt; Self {&#10;        Self {&#10;            level: &quot;trace&quot;.to_string(),&#10;            format: Format::Compact,&#10;            display: DisplayConfig {&#10;                colors: false,&#10;                time: false,&#10;                ..DisplayConfig::default()&#10;            },&#10;            ..Self::default()&#10;        }&#10;    }&#10;}&#10;&#10;impl Default for DisplayConfig {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            time: true,&#10;            time_format: None,&#10;            source: cfg!(debug_assertions),&#10;            target: true,&#10;            thread_ids: false,&#10;            thread_names: false,&#10;            colors: cfg!(feature = &quot;ansi&quot;) &amp;&amp; std::io::IsTerminal::is_terminal(&amp;std::io::stderr()),&#10;            span_list: true,&#10;            flatten: true,&#10;        }&#10;    }&#10;}&#10;&#10;impl DisplayConfig {&#10;    fn parse_env(&amp;mut self) {&#10;        if let Ok(v) = std::env::var(&quot;NEBULA_LOG_TIME&quot;) {&#10;            self.time = v != &quot;0&quot; &amp;&amp; v != &quot;false&quot;;&#10;        }&#10;        if let Ok(v) = std::env::var(&quot;NEBULA_LOG_SOURCE&quot;) {&#10;            self.source = v != &quot;0&quot; &amp;&amp; v != &quot;false&quot;;&#10;        }&#10;        if let Ok(v) = std::env::var(&quot;NEBULA_LOG_COLORS&quot;) {&#10;            self.colors = v != &quot;0&quot; &amp;&amp; v != &quot;false&quot;;&#10;        }&#10;    }&#10;}&#10;&#10;impl Fields {&#10;    /// Create fields from environment variables&#10;    pub fn from_env() -&gt; Self {&#10;        Self {&#10;            service: std::env::var(&quot;NEBULA_SERVICE&quot;).ok(),&#10;            env: std::env::var(&quot;NEBULA_ENV&quot;).ok(),&#10;            version: std::env::var(&quot;NEBULA_VERSION&quot;).ok()&#10;                .or_else(|| option_env!(&quot;CARGO_PKG_VERSION&quot;).map(String::from)),&#10;            instance: std::env::var(&quot;NEBULA_INSTANCE&quot;).ok(),&#10;            region: std::env::var(&quot;NEBULA_REGION&quot;).ok(),&#10;            custom: Default::default(),&#10;        }&#10;    }&#10;&#10;    /// Check if fields are empty&#10;    pub fn is_empty(&amp;self) -&gt; bool {&#10;        self.service.is_none()&#10;            &amp;&amp; self.env.is_none()&#10;            &amp;&amp; self.version.is_none()&#10;            &amp;&amp; self.instance.is_none()&#10;            &amp;&amp; self.region.is_none()&#10;            &amp;&amp; self.custom.is_empty()&#10;    }&#10;}&#10;&#10;impl Default for WriterConfig {&#10;    fn default() -&gt; Self {&#10;        Self::Stderr&#10;    }&#10;}&#10;&#10;fn default_true() -&gt; bool {&#10;    true&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crates/nebula-log/src/layer/fields.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crates/nebula-log/src/layer/fields.rs" />
              <option name="originalContent" value="//! Layer for injecting global fields&#10;&#10;use crate::config::Fields;&#10;use tracing::{Event, Subscriber};&#10;use tracing_subscriber::{&#10;    layer::{Context, Layer},&#10;    registry::LookupSpan,&#10;};&#10;&#10;/// Layer that adds global fields to spans&#10;pub struct FieldsLayer {&#10;    fields: Fields,&#10;}&#10;&#10;impl FieldsLayer {&#10;    pub fn new(fields: Fields) -&gt; Self {&#10;        Self { fields }&#10;    }&#10;}&#10;&#10;impl&lt;S&gt; Layer&lt;S&gt; for FieldsLayer&#10;where&#10;    S: Subscriber + for&lt;'a&gt; LookupSpan&lt;'a&gt;,&#10;{&#10;    fn on_new_span(&#10;        &amp;self,&#10;        attrs: &amp;tracing::span::Attributes&lt;'_&gt;,&#10;        id: &amp;tracing::span::Id,&#10;        ctx: Context&lt;'_, S&gt;,&#10;    ) {&#10;        // Fields are handled via root span in builder&#10;    }&#10;&#10;    fn on_event(&amp;self, event: &amp;Event&lt;'_&gt;, ctx: Context&lt;'_, S&gt;) {&#10;        // Context fields could be injected here if needed&#10;        // For now, we rely on the root span approach&#10;    }&#10;}" />
              <option name="updatedContent" value="//! Layer for injecting global fields&#10;&#10;use crate::config::Fields;&#10;use tracing::{Event, Subscriber};&#10;use tracing_subscriber::{&#10;    layer::{Context, Layer},&#10;    registry::LookupSpan,&#10;};&#10;&#10;/// Layer that adds global fields to spans&#10;pub struct FieldsLayer {&#10;    fields: Fields,&#10;}&#10;&#10;impl FieldsLayer {&#10;    pub fn new(fields: Fields) -&gt; Self {&#10;        Self { fields }&#10;    }&#10;}&#10;&#10;impl&lt;S&gt; Layer&lt;S&gt; for FieldsLayer&#10;where&#10;    S: Subscriber + for&lt;'a&gt; LookupSpan&lt;'a&gt;,&#10;{&#10;    fn on_new_span(&#10;        &amp;self,&#10;        _attrs: &amp;tracing::span::Attributes&lt;'_&gt;,&#10;        _id: &amp;tracing::span::Id,&#10;        _ctx: Context&lt;'_, S&gt;,&#10;    ) {&#10;        // TODO: Add global fields to span&#10;    }&#10;&#10;    fn on_event(&amp;self, _event: &amp;Event&lt;'_&gt;, _ctx: Context&lt;'_, S&gt;) {&#10;        // TODO: Add global fields to event&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crates/nebula-log/src/lib.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crates/nebula-log/src/lib.rs" />
              <option name="originalContent" value="//! # Nebula Log - Production-Ready Rust Logging&#10;//!&#10;//! Zero-config logging that scales from development to production.&#10;//!&#10;//! ## Quick Start&#10;//!&#10;//! ```rust&#10;//! use nebula_log::prelude::*;&#10;//!&#10;//! fn main() -&gt; Result&lt;()&gt; {&#10;//!     // Auto-detect best configuration&#10;//!     nebula_log::auto_init()?;&#10;//!&#10;//!     info!(port = 8080, &quot;Server starting&quot;);&#10;//!     Ok(())&#10;//! }&#10;//! ```&#10;&#10;#![forbid(unsafe_code)]&#10;#![warn(missing_docs, rust_2018_idioms)]&#10;&#10;mod builder;&#10;mod config;&#10;mod format;&#10;mod layer;&#10;mod writer;&#10;mod timing;&#10;mod macros;&#10;mod utils;&#10;&#10;#[cfg(any(feature = &quot;telemetry&quot;, feature = &quot;sentry&quot;))]&#10;mod telemetry;&#10;&#10;// Public API&#10;pub use builder::{LoggerBuilder, LoggerGuard};&#10;pub use config::{Config, Format, Level, Rolling};&#10;pub use timing::{Timer, TimerGuard, Timed};&#10;pub use layer::context::{Context, ContextGuard, Fields};&#10;&#10;/// Prelude for common imports&#10;pub mod prelude {&#10;    pub use crate::{&#10;        auto_init, init, init_with,&#10;        debug, error, info, trace, warn,&#10;        span, instrument, Level,&#10;        Timer, Timed,&#10;        Result,&#10;    };&#10;&#10;    pub use tracing::{field, Span};&#10;}&#10;&#10;// Re-export tracing macros&#10;pub use tracing::{debug, error, info, trace, warn, span, instrument};&#10;&#10;/// Result type for logger operations&#10;pub type Result&lt;T&gt; = anyhow::Result&lt;T&gt;;&#10;&#10;/// Error type for logger operations&#10;#[derive(Debug, thiserror::Error)]&#10;pub enum Error {&#10;    /// Configuration error&#10;    #[error(&quot;Configuration error: {0}&quot;)]&#10;    Config(String),&#10;&#10;    /// IO error&#10;    #[error(&quot;IO error: {0}&quot;)]&#10;    Io(#[from] std::io::Error),&#10;&#10;    /// Filter parsing error&#10;    #[error(&quot;Invalid filter: {0}&quot;)]&#10;    Filter(String),&#10;}&#10;&#10;// Test initialization guard&#10;#[cfg(test)]&#10;static TEST_INIT: std::sync::OnceLock&lt;()&gt; = std::sync::OnceLock::new();&#10;&#10;// ============================================================================&#10;// Initialization Functions&#10;// ============================================================================&#10;&#10;/// Auto-detect and initialize the best logging configuration&#10;pub fn auto_init() -&gt; Result&lt;LoggerGuard&gt; {&#10;    #[cfg(test)]&#10;    {&#10;        TEST_INIT.get_or_init(|| ());&#10;        if tracing::dispatcher::has_been_set() {&#10;            return Ok(LoggerGuard::noop());&#10;        }&#10;    }&#10;&#10;    if std::env::var(&quot;NEBULA_LOG&quot;).is_ok() || std::env::var(&quot;RUST_LOG&quot;).is_ok() {&#10;        init_with(Config::from_env())&#10;    } else if cfg!(debug_assertions) {&#10;        init_with(Config::development())&#10;    } else {&#10;        init_with(Config::production())&#10;    }&#10;}&#10;&#10;/// Initialize with default configuration&#10;pub fn init() -&gt; Result&lt;LoggerGuard&gt; {&#10;    init_with(Config::default())&#10;}&#10;&#10;/// Initialize with custom configuration&#10;pub fn init_with(config: Config) -&gt; Result&lt;LoggerGuard&gt; {&#10;    LoggerBuilder::from_config(config).build()&#10;}&#10;&#10;/// Initialize for tests (captures logs)&#10;#[cfg(test)]&#10;pub fn init_test() -&gt; Result&lt;LoggerGuard&gt; {&#10;    TEST_INIT.get_or_init(|| ());&#10;    if tracing::dispatcher::has_been_set() {&#10;        return Ok(LoggerGuard::noop());&#10;    }&#10;    init_with(Config::test())&#10;}" />
              <option name="updatedContent" value="//! # Nebula Log - Production-Ready Rust Logging&#10;//!&#10;//! Zero-config logging that scales from development to production.&#10;//!&#10;//! ## Quick Start&#10;//!&#10;//! ```rust&#10;//! use nebula_log::prelude::*;&#10;//!&#10;//! fn main() -&gt; Result&lt;()&gt; {&#10;//!     // Auto-detect best configuration&#10;//!     nebula_log::auto_init()?;&#10;//!&#10;//!     info!(port = 8080, &quot;Server starting&quot;);&#10;//!     Ok(())&#10;//! }&#10;//! ```&#10;&#10;#![forbid(unsafe_code)]&#10;#![warn(missing_docs, rust_2018_idioms)]&#10;&#10;mod builder;&#10;mod config;&#10;mod format;&#10;mod layer;&#10;mod writer;&#10;mod timing;&#10;mod macros;&#10;mod utils;&#10;&#10;#[cfg(any(feature = &quot;telemetry&quot;, feature = &quot;sentry&quot;))]&#10;mod telemetry;&#10;&#10;// Public API&#10;pub use builder::{LoggerBuilder, LoggerGuard};&#10;pub use config::{Config, Format, Level, Rolling, WriterConfig};&#10;pub use timing::{Timer, TimerGuard, Timed};&#10;pub use layer::context::{Context, ContextGuard, Fields};&#10;&#10;/// Prelude for common imports&#10;pub mod prelude {&#10;    pub use crate::{&#10;        auto_init, init, init_with,&#10;        debug, error, info, trace, warn,&#10;        span, instrument, Level,&#10;        Timer, Timed,&#10;        Result,&#10;    };&#10;&#10;    pub use tracing::{field, Span};&#10;}&#10;&#10;// Re-export tracing macros&#10;pub use tracing::{debug, error, info, trace, warn, span, instrument};&#10;&#10;/// Result type for logger operations&#10;pub type Result&lt;T&gt; = anyhow::Result&lt;T&gt;;&#10;&#10;/// Error type for logger operations&#10;#[derive(Debug, thiserror::Error)]&#10;pub enum Error {&#10;    /// Configuration error&#10;    #[error(&quot;Configuration error: {0}&quot;)]&#10;    Config(String),&#10;&#10;    /// IO error&#10;    #[error(&quot;IO error: {0}&quot;)]&#10;    Io(#[from] std::io::Error),&#10;&#10;    /// Filter parsing error&#10;    #[error(&quot;Invalid filter: {0}&quot;)]&#10;    Filter(String),&#10;}&#10;&#10;// Test initialization guard&#10;#[cfg(test)]&#10;static TEST_INIT: std::sync::OnceLock&lt;()&gt; = std::sync::OnceLock::new();&#10;&#10;// ============================================================================&#10;// Initialization Functions&#10;// ============================================================================&#10;&#10;/// Auto-detect and initialize the best logging configuration&#10;pub fn auto_init() -&gt; Result&lt;LoggerGuard&gt; {&#10;    #[cfg(test)]&#10;    {&#10;        TEST_INIT.get_or_init(|| ());&#10;        if tracing::dispatcher::has_been_set() {&#10;            return Ok(LoggerGuard::noop());&#10;        }&#10;    }&#10;&#10;    if std::env::var(&quot;NEBULA_LOG&quot;).is_ok() || std::env::var(&quot;RUST_LOG&quot;).is_ok() {&#10;        init_with(Config::from_env())&#10;    } else if cfg!(debug_assertions) {&#10;        init_with(Config::development())&#10;    } else {&#10;        init_with(Config::production())&#10;    }&#10;}&#10;&#10;/// Initialize with default configuration&#10;pub fn init() -&gt; Result&lt;LoggerGuard&gt; {&#10;    init_with(Config::default())&#10;}&#10;&#10;/// Initialize with custom configuration&#10;pub fn init_with(config: Config) -&gt; Result&lt;LoggerGuard&gt; {&#10;    LoggerBuilder::from_config(config).build()&#10;}&#10;&#10;/// Initialize for tests (captures logs)&#10;#[cfg(test)]&#10;pub fn init_test() -&gt; Result&lt;LoggerGuard&gt; {&#10;    TEST_INIT.get_or_init(|| ());&#10;    if tracing::dispatcher::has_been_set() {&#10;        return Ok(LoggerGuard::noop());&#10;    }&#10;    init_with(Config::test())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crates/nebula-log/src/macros.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crates/nebula-log/src/macros.rs" />
              <option name="originalContent" value="//! Utility macros&#10;use tracing::Instrument;&#10;&#10;/// Time a block of code&#10;#[macro_export]&#10;macro_rules! timed {&#10;    ($name:expr, $body:expr) =&gt; {{&#10;        let _timer = $crate::TimerGuard::new($name);&#10;        $body&#10;    }};&#10;}&#10;&#10;/// Time an async block&#10;#[macro_export]&#10;macro_rules! async_timed {&#10;    ($name:expr, $body:expr) =&gt; {{&#10;        use $crate::Timed;&#10;        async move { $body }.timed($name).await&#10;    }};&#10;}&#10;&#10;/// Log an error and return it&#10;#[macro_export]&#10;macro_rules! log_error {&#10;    ($err:expr) =&gt; {{&#10;        let e = $err;&#10;        $crate::error!(error = ?e);&#10;        e&#10;    }};&#10;    ($err:expr, $($arg:tt)*) =&gt; {{&#10;        let e = $err;&#10;        $crate::error!(error = ?e, $($arg)*);&#10;        e&#10;    }};&#10;}&#10;&#10;/// Create a span with timing&#10;#[macro_export]&#10;macro_rules! timed_span {&#10;    ($name:expr) =&gt; {&#10;        tracing::info_span!($name, elapsed_ms = tracing::field::Empty)&#10;    };&#10;    ($level:expr, $name:expr) =&gt; {&#10;        tracing::span!($level, $name, elapsed_ms = tracing::field::Empty)&#10;    };&#10;    ($level:expr, $name:expr, $($field:tt)*) =&gt; {&#10;        tracing::span!($level, $name, elapsed_ms = tracing::field::Empty, $($field)*)&#10;    };&#10;}&#10;&#10;/// Log and measure an async operation&#10;#[macro_export]&#10;macro_rules! measure {&#10;    ($name:expr, $future:expr) =&gt; {{&#10;        let __start = std::time::Instant::now();&#10;        let span = $crate::timed_span!($name);&#10;        async move {&#10;            let result = $future.await;&#10;            span.record(&quot;elapsed_ms&quot;, &amp;__start.elapsed().as_millis());&#10;            result&#10;        }&#10;        .instrument(span)&#10;        .await&#10;    }};&#10;}&#10;&#10;/// Set context fields for current scope&#10;#[macro_export]&#10;macro_rules! with_context {&#10;    ($($key:ident = $value:expr),* $(,)?) =&gt; {{&#10;        let ctx = $crate::Context::current()&#10;            $(.with_field(stringify!($key), $value))*;&#10;        ctx.set_current()&#10;    }};&#10;}" />
              <option name="updatedContent" value="//! Convenience macros for structured logging&#10;&#10;/// Time a block of code&#10;#[macro_export]&#10;macro_rules! timed {&#10;    ($name:expr, $body:expr) =&gt; {{&#10;        let _timer = $crate::TimerGuard::new($name);&#10;        $body&#10;    }};&#10;}&#10;&#10;/// Time an async block&#10;#[macro_export]&#10;macro_rules! async_timed {&#10;    ($name:expr, $body:expr) =&gt; {{&#10;        use $crate::Timed;&#10;        async move { $body }.timed($name).await&#10;    }};&#10;}&#10;&#10;/// Log an error and return it&#10;#[macro_export]&#10;macro_rules! log_error {&#10;    ($err:expr) =&gt; {{&#10;        let e = $err;&#10;        $crate::error!(error = ?e);&#10;        e&#10;    }};&#10;    ($err:expr, $($arg:tt)*) =&gt; {{&#10;        let e = $err;&#10;        $crate::error!(error = ?e, $($arg)*);&#10;        e&#10;    }};&#10;}&#10;&#10;/// Create a span with timing&#10;#[macro_export]&#10;macro_rules! timed_span {&#10;    ($name:expr) =&gt; {&#10;        tracing::info_span!($name, elapsed_ms = tracing::field::Empty)&#10;    };&#10;    ($level:expr, $name:expr) =&gt; {&#10;        tracing::span!($level, $name, elapsed_ms = tracing::field::Empty)&#10;    };&#10;    ($level:expr, $name:expr, $($field:tt)*) =&gt; {&#10;        tracing::span!($level, $name, elapsed_ms = tracing::field::Empty, $($field)*)&#10;    };&#10;}&#10;&#10;/// Log and measure an async operation&#10;#[macro_export]&#10;macro_rules! measure {&#10;    ($name:expr, $future:expr) =&gt; {{&#10;        use tracing::Instrument;&#10;        let __start = std::time::Instant::now();&#10;        let span = $crate::timed_span!($name);&#10;        let instrumented_future = async move {&#10;            let result = $future.await;&#10;            result&#10;        }.instrument(span);&#10;        &#10;        let result = instrumented_future.await;&#10;        let elapsed = __start.elapsed().as_millis();&#10;        tracing::info!(name = %$name, elapsed_ms = elapsed, &quot;Operation completed&quot;);&#10;        result&#10;    }};&#10;}&#10;&#10;/// Set context fields for current scope&#10;#[macro_export]&#10;macro_rules! with_context {&#10;    ($($key:ident = $value:expr),* $(,)?) =&gt; {{&#10;        let ctx = $crate::Context::current()&#10;            $(.with_field(stringify!($key), $value))*;&#10;        ctx.set_current()&#10;    }};&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crates/nebula-log/src/timing.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crates/nebula-log/src/timing.rs" />
              <option name="originalContent" value="//! Performance timing utilities&#10;&#10;use std::future::Future;&#10;use std::pin::Pin;&#10;use std::task::{Context, Poll};&#10;use std::time::{Duration, Instant};&#10;use tracing::Instrument;&#10;use pin_project::pin_project;&#10;&#10;/// A timer that measures execution time&#10;#[derive(Debug)]&#10;pub struct Timer {&#10;    name: String,&#10;    start: Instant,&#10;    level: tracing::Level,&#10;    threshold: Option&lt;Duration&gt;,&#10;}&#10;&#10;impl Timer {&#10;    /// Create a new timer&#10;    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {&#10;        Self {&#10;            name: name.into(),&#10;            start: Instant::now(),&#10;            level: tracing::Level::INFO,&#10;            threshold: None,&#10;        }&#10;    }&#10;&#10;    /// Set the log level&#10;    pub fn level(mut self, level: tracing::Level) -&gt; Self {&#10;        self.level = level;&#10;        self&#10;    }&#10;&#10;    /// Only log if duration exceeds threshold&#10;    pub fn threshold(mut self, duration: Duration) -&gt; Self {&#10;        self.threshold = Some(duration);&#10;        self&#10;    }&#10;&#10;    /// Get elapsed time&#10;    pub fn elapsed(&amp;self) -&gt; Duration {&#10;        self.start.elapsed()&#10;    }&#10;&#10;    /// Complete the timer&#10;    pub fn complete(self) -&gt; Duration {&#10;        let elapsed = self.elapsed();&#10;&#10;        if let Some(threshold) = self.threshold {&#10;            if elapsed &lt; threshold {&#10;                return elapsed;&#10;            }&#10;        }&#10;&#10;        let ms = elapsed.as_millis();&#10;        match self.level {&#10;            tracing::Level::ERROR =&gt; tracing::error!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::WARN =&gt; tracing::warn!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::INFO =&gt; tracing::info!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::DEBUG =&gt; tracing::debug!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::TRACE =&gt; tracing::trace!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;        }&#10;&#10;        elapsed&#10;    }&#10;}&#10;&#10;/// RAII guard for automatic timing&#10;pub struct TimerGuard {&#10;    timer: Option&lt;Timer&gt;,&#10;}&#10;&#10;impl TimerGuard {&#10;    /// Create a new timer guard&#10;    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {&#10;        Self {&#10;            timer: Some(Timer::new(name)),&#10;        }&#10;    }&#10;}&#10;&#10;impl Drop for TimerGuard {&#10;    fn drop(&amp;mut self) {&#10;        if let Some(timer) = self.timer.take() {&#10;            timer.complete();&#10;        }&#10;    }&#10;}&#10;&#10;/// Extension trait for timing futures&#10;pub trait Timed: Sized {&#10;    /// Time the execution of this future&#10;    fn timed(self, name: impl Into&lt;String&gt;) -&gt; TimedFuture&lt;Self&gt; {&#10;        TimedFuture {&#10;            inner: self,&#10;            timer: Timer::new(name),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;F&gt; Timed for F where F: Future {}&#10;&#10;/// A future that times its execution&#10;#[pin_project]&#10;pub struct TimedFuture&lt;F&gt; {&#10;    #[pin]&#10;    inner: F,&#10;    timer: Timer,&#10;}&#10;&#10;impl&lt;F: Future&gt; Future for TimedFuture&lt;F&gt; {&#10;    type Output = F::Output;&#10;&#10;    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {&#10;        let this = self.project();&#10;        let result = this.inner.poll(cx);&#10;&#10;        if result.is_ready() {&#10;            let elapsed = this.timer.start.elapsed();&#10;            let ms = elapsed.as_millis();&#10;            tracing::info!(name = %this.timer.name, ms, &quot;Future completed&quot;);&#10;        }&#10;&#10;        result&#10;    }&#10;}" />
              <option name="updatedContent" value="//! Performance timing utilities&#10;&#10;use std::future::Future;&#10;use std::pin::Pin;&#10;use std::task::{Context, Poll};&#10;use std::time::{Duration, Instant};&#10;&#10;use pin_project::pin_project;&#10;&#10;/// A timer that measures execution time&#10;#[derive(Debug)]&#10;pub struct Timer {&#10;    name: String,&#10;    start: Instant,&#10;    level: tracing::Level,&#10;    threshold: Option&lt;Duration&gt;,&#10;}&#10;&#10;impl Timer {&#10;    /// Create a new timer&#10;    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {&#10;        Self {&#10;            name: name.into(),&#10;            start: Instant::now(),&#10;            level: tracing::Level::INFO,&#10;            threshold: None,&#10;        }&#10;    }&#10;&#10;    /// Set the log level&#10;    pub fn level(mut self, level: tracing::Level) -&gt; Self {&#10;        self.level = level;&#10;        self&#10;    }&#10;&#10;    /// Only log if duration exceeds threshold&#10;    pub fn threshold(mut self, duration: Duration) -&gt; Self {&#10;        self.threshold = Some(duration);&#10;        self&#10;    }&#10;&#10;    /// Get elapsed time&#10;    pub fn elapsed(&amp;self) -&gt; Duration {&#10;        self.start.elapsed()&#10;    }&#10;&#10;    /// Complete the timer&#10;    pub fn complete(self) -&gt; Duration {&#10;        let elapsed = self.elapsed();&#10;&#10;        if let Some(threshold) = self.threshold&#10;            &amp;&amp; elapsed &lt; threshold {&#10;            return elapsed;&#10;        }&#10;&#10;        let ms = elapsed.as_millis();&#10;        match self.level {&#10;            tracing::Level::ERROR =&gt; tracing::error!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::WARN =&gt; tracing::warn!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::INFO =&gt; tracing::info!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::DEBUG =&gt; tracing::debug!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;            tracing::Level::TRACE =&gt; tracing::trace!(name = %self.name, ms, &quot;Timer completed&quot;),&#10;        }&#10;&#10;        elapsed&#10;    }&#10;}&#10;&#10;/// RAII guard for automatic timing&#10;pub struct TimerGuard {&#10;    timer: Option&lt;Timer&gt;,&#10;}&#10;&#10;impl TimerGuard {&#10;    /// Create a new timer guard&#10;    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {&#10;        Self {&#10;            timer: Some(Timer::new(name)),&#10;        }&#10;    }&#10;}&#10;&#10;impl Drop for TimerGuard {&#10;    fn drop(&amp;mut self) {&#10;        if let Some(timer) = self.timer.take() {&#10;            timer.complete();&#10;        }&#10;    }&#10;}&#10;&#10;/// Extension trait for timing futures&#10;pub trait Timed: Sized {&#10;    /// Time the execution of this future&#10;    fn timed(self, name: impl Into&lt;String&gt;) -&gt; TimedFuture&lt;Self&gt; {&#10;        TimedFuture {&#10;            inner: self,&#10;            timer: Timer::new(name),&#10;        }&#10;    }&#10;}&#10;&#10;impl&lt;F&gt; Timed for F where F: Future {}&#10;&#10;/// A future that times its execution&#10;#[pin_project]&#10;pub struct TimedFuture&lt;F&gt; {&#10;    #[pin]&#10;    inner: F,&#10;    timer: Timer,&#10;}&#10;&#10;impl&lt;F: Future&gt; Future for TimedFuture&lt;F&gt; {&#10;    type Output = F::Output;&#10;&#10;    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {&#10;        let this = self.project();&#10;        let result = this.inner.poll(cx);&#10;&#10;        if result.is_ready() {&#10;            let elapsed = this.timer.start.elapsed();&#10;            let ms = elapsed.as_millis();&#10;            tracing::info!(name = %this.timer.name, ms, &quot;Future completed&quot;);&#10;        }&#10;&#10;        result&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>